

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>The CC2640R2F SDK Platform &mdash; Bluetooth Low Energy Software Developer&#39;s Guide 3.00.01 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  

  
    <link rel="top" title="Bluetooth Low Energy Software Developer&#39;s Guide 3.00.01 documentation" href="../index.html"/>
        <link rel="next" title="Developing a Bluetooth Low Energy Application" href="../ble-stack/index.html"/>
        <link rel="prev" title="Getting Started" href="get-started/get-started.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Bluetooth Low Energy Software Developer's Guide
          

          
          </a>

          
            
            
              <div class="version">
                3.00.01
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="disclaimer.html">Disclaimer</a></li>
<li class="toctree-l1"><a class="reference internal" href="get-started/get-started.html">Getting Started</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">The CC2640R2F SDK Platform</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#architecture">Architecture</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#hardware-and-software-architecture">Hardware and Software Architecture</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#arm-cortex-m0-radio-core">ARM Cortex M0 (Radio Core)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#arm-cortex-m3-system-core">ARM Cortex M3 (System Core)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#ble-stack-protocol-stack-and-application-configurations">BLE-Stack Protocol Stack and Application Configurations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#solution-platform">Solution Platform</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ble-software-architecture">BLE Software Architecture</a></li>
<li class="toctree-l3"><a class="reference internal" href="#protocol-stack-build-configurations">Protocol Stack Build Configurations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#stack-library-configuration-stack-library">Stack Library Configuration (<code class="docutils literal"><span class="pre">_stack_library</span></code>)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#split-image-configuration">Split Image Configuration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#project-build-configurations">Project Build Configurations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#converting-library-build-to-split-image">Converting Library Build to Split Image</a></li>
<li class="toctree-l4"><a class="reference internal" href="#standard-project-task-hierarchy">Standard Project Task Hierarchy</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#directory-structure">Directory Structure</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#examples-folder">Examples Folder</a></li>
<li class="toctree-l4"><a class="reference internal" href="#source-folder">Source Folder</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#working-with-hex-and-binary-files">Working With Hex and Binary Files</a></li>
<li class="toctree-l3"><a class="reference internal" href="#programming-internal-flash-with-the-rom-bootloader">Programming Internal Flash with the ROM Bootloader</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#installing-blestack">Installing BLE-Stack 3.00.01</a></li>
<li class="toctree-l2"><a class="reference internal" href="#developing-with-ccs">Developing with CCS</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#installing-code-composer-studio-ccs">Installing Code Composer Studio (CCS)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#installing-a-specific-ti-arm-compiler">Installing a Specific TI ARM Compiler</a></li>
<li class="toctree-l3"><a class="reference internal" href="#importing-ccs-projects">Importing CCS projects</a></li>
<li class="toctree-l3"><a class="reference internal" href="#discovering-ccs-products">Discovering CCS products</a></li>
<li class="toctree-l3"><a class="reference internal" href="#blestack-ccs-project-build-configurations">BLE-Stack 3.00.01 CCS project build configurations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#compiling-and-download">Compiling and Download</a></li>
<li class="toctree-l3"><a class="reference internal" href="#accessing-preprocessor-symbols">Accessing Preprocessor Symbols</a></li>
<li class="toctree-l3"><a class="reference internal" href="#accessing-linker-symbols">Accessing Linker Symbols</a></li>
<li class="toctree-l3"><a class="reference internal" href="#resetting-the-device-in-ccs">Resetting the CC2640R2F in CCS</a></li>
<li class="toctree-l3"><a class="reference internal" href="#additional-training-and-support-for-ccs">Additional training and support for CCS</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#developing-with-iar">Developing with IAR</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#installing-iar">Installing IAR</a></li>
<li class="toctree-l3"><a class="reference internal" href="#opening-iar-projects">Opening IAR Projects</a></li>
<li class="toctree-l3"><a class="reference internal" href="#blestack-iar-project-build-configurations">BLE-Stack 3.00.01 IAR project build configurations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#compile-and-download">Compile and Download</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sec-developing-with-iar-accessing-preprocessor-symbols">Accessing Preprocessor Symbols</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sec-developing-with-iar-accessing-linker-symbols">Accessing Linker Symbols</a></li>
<li class="toctree-l3"><a class="reference internal" href="#resetting-the-device-in-iar">Resetting the CC2640R2F in IAR</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#ti-rtos-overview">TI-RTOS Overview</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#threading-modules">Threading Modules</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#hardware-interrupts-hwi">Hardware Interrupts (Hwi)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#software-interrupts-swi">Software Interrupts (Swi)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#task">Task</a></li>
<li class="toctree-l4"><a class="reference internal" href="#idle-task">Idle Task</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#kernel-configuration">Kernel Configuration</a></li>
<li class="toctree-l3"><a class="reference internal" href="#creating-vs-constructing">Creating vs. Constructing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#thread-synchronization">Thread Synchronization</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#semaphores">Semaphores</a></li>
<li class="toctree-l4"><a class="reference internal" href="#event">Event</a></li>
<li class="toctree-l4"><a class="reference internal" href="#queues">Queues</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#tasks">Tasks</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#initializing-a-task">Initializing a Task</a></li>
<li class="toctree-l4"><a class="reference internal" href="#a-task-function">A Task Function</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#clocks">Clocks</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#sec-rtos-overview-functional-clock-example">Functional Example</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#drivers">Drivers</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#adding-a-driver">Adding a Driver</a></li>
<li class="toctree-l4"><a class="reference internal" href="#board-file">Board File</a></li>
<li class="toctree-l4"><a class="reference internal" href="#available-drivers">Available Drivers</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#power-management">Power Management</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#memory-management">Memory Management</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#flash">Flash</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#flash-memory-map">Flash Memory Map</a></li>
<li class="toctree-l4"><a class="reference internal" href="#application-and-stack-flash-boundary">Application and Stack Flash Boundary</a></li>
<li class="toctree-l4"><a class="reference internal" href="#using-simple-nv-for-flash-storage">Using Simple NV for Flash Storage</a></li>
<li class="toctree-l4"><a class="reference internal" href="#customer-configuration-area">Customer Configuration Area</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#ram">RAM</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#ram-memory-map">RAM Memory Map</a></li>
<li class="toctree-l4"><a class="reference internal" href="#application-and-stack-ram-boundary">Application and Stack RAM Boundary</a></li>
<li class="toctree-l4"><a class="reference internal" href="#system-stack">System Stack</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dynamic-memory-allocation">Dynamic Memory Allocation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#cache-gpram">Cache/GPRAM</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#using-the-cache-as-ram">Using the Cache as RAM</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#aux-ram">AUX RAM</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#using-the-aux-ram-as-ram">Using the AUX RAM as RAM</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#frontier-tool">Frontier Tool</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#frontier-tool-operation">Frontier Tool Operation</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../ble-stack/index.html">Developing a Bluetooth Low Energy Application</a></li>
<li class="toctree-l1"><a class="reference internal" href="../u-stack/index.html">Micro BLE Stack</a></li>
<li class="toctree-l1"><a class="reference internal" href="../oad/oad.html">Over the Air Download (OAD)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../voice/voice.html">Creating a Voice Enabled Application</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sensor-controller/sensor-controller.html">Sensor Controller</a></li>
<li class="toctree-l1"><a class="reference internal" href="../debugging/ble-debugging.html">Debugging</a></li>
<li class="toctree-l1"><a class="reference internal" href="ble-sdg/migration.html">Migration Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="reference.html">References</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Bluetooth Low Energy Software Developer's Guide</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>The CC2640R2F SDK Platform</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/cc2640/platform.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="the-device-sdk-platform">
<h1>The CC2640R2F SDK Platform<a class="headerlink" href="#the-device-sdk-platform" title="Permalink to this headline">¶</a></h1>
<div class="section" id="architecture">
<h2>Architecture<a class="headerlink" href="#architecture" title="Permalink to this headline">¶</a></h2>
<p>The TI royalty-free Bluetooth low energy software development kit (SDK) is a
complete software platform for developing single-mode Bluetooth low energy
applications. This kit is based on the SimpleLink CC2640R2F, complete
System-on-Chip (SoC) Bluetooth low energy solution. The CC2640R2F combines a
2.4-GHz RF transceiver, 128-KB in-system programmable memory, 20KB of SRAM, and
a full range of peripherals. The device is centered on an ARM<sup>®</sup>
Cortex<sup>®</sup>-M3 series processor that handles the application layer and
Bluetooth low energy protocol stack and an autonomous radio core centered on an
ARM Cortex<sup>®</sup>-M0 processor that handles all the low-level radio control
and processing associated with the physical layer and parts of the link layer.
The sensor controller block provides additional flexibility by allowing
autonomous data acquisition and control independent of the Cortex-M3 processor,
further extending the low-power capabilities of the CC2640R2F.
<a class="reference internal" href="#fig-simplelink-block-diagram"><span class="std std-numref">Figure 3.</span></a> shows the block diagram. For more
information on the CC2640R2F, see the <a class="reference external" href="http://www.ti.com/lit/pdf/swcu117">CC26xx Technical Reference Manual</a>.</p>
<div class="figure align-center" id="id15">
<span id="fig-simplelink-block-diagram"></span><img alt="../_images/image6.jpeg" src="../_images/image6.jpeg" />
<p class="caption"><span class="caption-number">Figure 3. </span><span class="caption-text">SimpleLink CC2640R2F Block Diagram</span></p>
</div>
<div class="section" id="hardware-and-software-architecture">
<h3>Hardware and Software Architecture<a class="headerlink" href="#hardware-and-software-architecture" title="Permalink to this headline">¶</a></h3>
<p>This section aims to introduce the different cores within the CC2640R2F, how they
interact, and the firmware that runs on them. The information presented here
should be considered as an overview. For detailed descriptions of the hardware
described here, refer to the chapter 23 of the <a class="reference external" href="http://www.ti.com/lit/pdf/swcu117">CC26xx Technical Reference Manual</a>.</p>
<div class="section" id="arm-cortex-m0-radio-core">
<h4>ARM Cortex M0 (Radio Core)<a class="headerlink" href="#arm-cortex-m0-radio-core" title="Permalink to this headline">¶</a></h4>
<p>The Cortex M0 (CM0) core within the CC2640R2F is responsible for both interfacing
to the radio hardware, and translating complex instructions from the Cortex M3
(CM3) core into bits that are sent over the air using the radio. For the
Bluetooth low energy protocol, the CM0 implements the PHY layer of the protocol
stack. Often, the CM0 is able to operate autonomously, which frees up the CM3
for higher-level protocol and application-layer processing.</p>
<p>The CM3 communicates with the CM0 through a hardware interface called the RF
doorbell, which is documented in section 23.2 of the <a class="reference external" href="http://www.ti.com/lit/pdf/swcu117">CC26xx Technical Reference Manual</a>. The radio core
firmware is not intended to be used or modified by the application developer.</p>
</div>
<div class="section" id="arm-cortex-m3-system-core">
<h4>ARM Cortex M3 (System Core)<a class="headerlink" href="#arm-cortex-m3-system-core" title="Permalink to this headline">¶</a></h4>
<p>The system core (CM3) is designed to run the Bluetooth low energy protocol stack
from the link layer up to the user application. The link layer interfaces to the
radio core through a software module called the RF driver, which sits above the
RF doorbell. The RF driver runs on the CM3 and acts as an interface to the radio
on the CC2640R2F, and also manages the power domains of the radio hardware and
core. Documentation for the RF driver can be found at the
<a class="reference external" href="../../../../tidrivers/tidriversAPIs.html">TI-RTOS Drivers Reference</a>.
Above the RF driver is the TI Bluetooth low energy protocol stack, which is
implemented in library code.</p>
<p>The application developer interfaces with the protocol stack through a set of APIs
(ICall) to implement a Bluetooth low energy application. The rest of this
document intends to document application development on the CC2640R2F using the
Bluetooth low energy stack.</p>
</div>
</div>
<div class="section" id="ble-stack-protocol-stack-and-application-configurations">
<h3>BLE-Stack Protocol Stack and Application Configurations<a class="headerlink" href="#ble-stack-protocol-stack-and-application-configurations" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="#fig-device-configurations"><span class="std std-numref">Figure 4.</span></a> shows the platform that supports two
different protocol stack and application configurations.</p>
<ul class="simple">
<li><strong>Single device:</strong> The controller, host, profiles, and application are all
implemented on the CC2640R2F as a true single-chip solution. This
configuration is the simplest and most common when using the CC2640R2F. This
configuration is used by most of TI&#8217;s sample projects. This configuration is
the most cost-effective technique and provides the lowest-power performance.</li>
<li><strong>Simple network processor:</strong> The Simple Network Processor (<a class="reference internal" href="glossary.html#term-snp"><span class="xref std std-term">SNP</span></a>)
implements the controller and host layers of the BLE-Stack. Additionally,
the SNP exposes an interface for scheduling communication between the stack
and an external MCU. This accelerates dual MCU designs because the
application processor (<a class="reference internal" href="glossary.html#term-ap"><span class="xref std std-term">AP</span></a>) is only responsible for managing custom
profiles and application code. Stack-related functionality, such as
security, is implemented on the SNP. The SNP currently supports the
peripheral and broadcaster GAP roles. Communication with the SNP is carried
out through the SNP API. The SNP API is built on the Unified Network
Processor Interface (<a class="reference internal" href="glossary.html#term-unpi"><span class="xref std std-term">UNPI</span></a>), which supports UART and SPI transport
layers. For more information, reference the Unified Network Processor
Interface wiki page. TI also provides the SAP library, which implements a
UNPI master and the SNP API. The SAP library can be ported to any
TI-RTOS-capable processor, or used as a reference for developing a custom
dual MCU solution. For a description of the SNP, see the README.html page
within the simple_np folder, advanced users can read the
<a class="reference external" href="../../doxygen/group___s_n_p.html">SNP API Reference</a> for a summary of the supported
commands.</li>
</ul>
<div class="figure align-center" id="id16">
<span id="fig-device-configurations"></span><a class="reference internal image-reference" href="../_images/image7.jpeg"><img alt="../_images/image7.jpeg" src="../_images/image7.jpeg" style="width: 75%;" /></a>
<p class="caption"><span class="caption-number">Figure 4. </span><span class="caption-text">Single-Device Processor and Simple Network Processor Configurations</span></p>
</div>
</div>
<div class="section" id="solution-platform">
<h3>Solution Platform<a class="headerlink" href="#solution-platform" title="Permalink to this headline">¶</a></h3>
<p>This section describes the various components that are installed with the
BLE-Stack 3.00.01 and the directory structure of the protocol stack
and any tools required for development.
<a class="reference internal" href="#fig-single-network-processor-configuration"><span class="std std-numref">Figure 5.</span></a> shows the BLE-Stack 3.00.01
development system.</p>
<div class="figure align-center" id="id17">
<span id="fig-single-network-processor-configuration"></span><img alt="../_images/image8.jpeg" src="../_images/image8.jpeg" />
<p class="caption"><span class="caption-number">Figure 5. </span><span class="caption-text">Bluetooth low energy Stack Development System</span></p>
</div>
<p>The solution platform includes the following components:</p>
<ul class="simple">
<li><strong>TI&#8217;s Real-Time Operating System (TI-RTOS)</strong> with the TI-RTOS kernel,
optimized power management support, and peripheral drivers (SPI, UART, and
so forth)</li>
<li><strong>CC26xxware DriverLib</strong> provides a register abstraction layer and is used
by software and drivers to control the CC2640R2F SoC.</li>
<li><strong>The Bluetooth low energy protocol stack</strong> is provided in library form with
parts of the protocol stack in the CC2640R2F ROM.</li>
<li><strong>Sample applications and profiles</strong> make starting development using both
proprietary and generic solutions easier.</li>
</ul>
<p>The following integrated development environments (IDEs) are
supported:</p>
<ul class="simple">
<li>IAR Embedded Workbench for ARM</li>
<li>Code Composer Studio™ (CCS)</li>
</ul>
<p>Refer to the SDK release notes for the specific IDE versions supported by this
release.</p>
</div>
<div class="section" id="ble-software-architecture">
<h3>BLE Software Architecture<a class="headerlink" href="#ble-software-architecture" title="Permalink to this headline">¶</a></h3>
<p>The CC2640R2F Bluetooth low energy software environment consists of the
following parts:</p>
<ul class="simple">
<li>An application image with the TI-RTOS kernel, drivers and Bluetooth profile</li>
<li>A stack image or library that implements Bluetooth low energy protocol</li>
</ul>
<p>TI-RTOS is a real-time, pre-emptive, multithreaded operating system that
runs the software solution with task synchronization. Both the application and
Bluetooth low energy protocol stack exist as separate tasks within the RTOS. The
Bluetooth low energy protocol stack has the highest priority. A messaging
framework called indirect call (ICall) is used for thread-safe synchronization
between the application and stack. <a class="reference internal" href="#fig-examples-software-architecture"><span class="std std-numref">Figure 6.</span></a>
shows the architecture.</p>
<div class="figure align-center" id="id18">
<span id="fig-examples-software-architecture"></span><img alt="../_images/image43.jpeg" src="../_images/image43.jpeg" />
<p class="caption"><span class="caption-number">Figure 6. </span><span class="caption-text">Example Software Architecture</span></p>
</div>
<ul class="simple">
<li>The stack image includes the lower layers of the Bluetooth low energy
protocol stack from the LL up to and including the GAP and GATT layers. Most
of the Bluetooth low energy protocol stack code is provided as a library.</li>
<li>The application image includes the RTOS, profiles, application code,
drivers, and the ICall module.</li>
</ul>
</div>
<div class="section" id="protocol-stack-build-configurations">
<span id="sec-supported-stack-image-types"></span><h3>Protocol Stack Build Configurations<a class="headerlink" href="#protocol-stack-build-configurations" title="Permalink to this headline">¶</a></h3>
<p>The BLE-Stack applications have different options for configuring the protocol
stack to maximize system implementations. These options are described below
along with the relevant advantages and limitations.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This section aims to explain the two supported protocol stack build
configurations. Additionally, the protocol stack itself may be configured
to conditionally pull in different library builds based on the features
needed. Configuring the protocol stack is covered in
<a class="reference internal" href="../ble-stack/index.html#stack-features-configuration"><span class="std std-ref">Stack Configurations</span></a></p>
</div>
<div class="section" id="stack-library-configuration-stack-library">
<span id="sec-inc-architecture-stack-image-as-a-library"></span><h4>Stack Library Configuration (<code class="docutils literal"><span class="pre">_stack_library</span></code>)<a class="headerlink" href="#stack-library-configuration-stack-library" title="Permalink to this headline">¶</a></h4>
<p>In BLE-Stack 3.00.01, stack can be built as a library that can be statically linked to
the application. Projects with build with this new configuration can be
identified by project build configurations with <code class="docutils literal"><span class="pre">_stack_library</span></code> in its
configuration name. Using this build configuration will yield additional flash
footprint optimizations by the linker since the application and stack can share
contiguous flash pages. The gained footprint savings will however prevent
<strong>split-image</strong> application- or on-chip OAD downloads. See
<a class="reference internal" href="#tbl-inc-developing-in-ccs-build-configs"><span class="std std-ref">Available CCS project build configurations</span></a> and
<a class="reference internal" href="#tbl-inc-developing-in-iar-build-configs"><span class="std std-ref">Available IAR project build configurations</span></a> for the available project build
configurations. Stack library projects have the following properties</p>
<blockquote>
<div><ul class="simple">
<li>Stack project generates a static library (.lib)</li>
<li>Application project will now link the stack in as a library</li>
<li>There is no explicit app/stack boundary. The application&#8217;s link step
decides the memory locations of the code within the stack_library. There
are some exceptions to this such as <a class="reference internal" href="glossary.html#term-37"><span class="xref std std-term">SNV</span></a>.</li>
<li>This architecture saves flash by allowing the linker work more efficiently.</li>
<li>These projects used the improved ICall architecture</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="split-image-configuration">
<span id="sec-inc-architecture-split-image-configuration"></span><h4>Split Image Configuration<a class="headerlink" href="#split-image-configuration" title="Permalink to this headline">¶</a></h4>
<p>As with previous BLE-Stack 2.x SDK releases, application and stack images are
built as two separate projects that generate two separate images.
These images occupy separate, non-overlapping flash memory pages. The split image
configuration is useful in purposes such as  on-chip <a class="reference internal" href="glossary.html#term-33"><span class="xref std std-term">OAD</span></a> where it could
be advantageous to perform independent application or stack downloads. Split
image projects have the following properties:</p>
<blockquote>
<div><ul class="simple">
<li>Fixed stack entry point</li>
<li>Stack project generates a separate executable (.hex, .out, .bin)</li>
<li>Explicit Flash/RAM boundaries between app and stack</li>
<li>Independent update of stack/app (API compatibility must be ensured by the
user)</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="project-build-configurations">
<h4>Project Build Configurations<a class="headerlink" href="#project-build-configurations" title="Permalink to this headline">¶</a></h4>
<p>Sample applications within the BLE-Stack 3.00.01 portion of the SimpleLink CC2640R2 SDK support multiple
build configurations to enable using the protocol stack build types discussed
above. Other build configurations may have been created to support features such
as RCOSC or OAD out of the box.
The table below gives a summary of the build configurations found within
BLE-Stack 3.00.01 and their compatibility with one another.</p>
<table border="1" class="docutils" id="id19">
<span id="id1"></span><caption><span class="caption-number">Table 2. </span><span class="caption-text">Available project build configurations.</span><a class="headerlink" href="#id19" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="10%" />
<col width="22%" />
<col width="68%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Project
type</td>
<td>Project’s
build configuration</td>
<td>Description</td>
</tr>
<tr class="row-even"><td rowspan="5">Application</td>
<td>FlashROM</td>
<td>Application image build configuration. Requires companion Stack FlashROM (split image
configuration)</td>
</tr>
<tr class="row-odd"><td>FlashROM_StackLibrary</td>
<td>Application build configuration linked to Stack library (fully executable)</td>
</tr>
<tr class="row-even"><td>FlashROM_StackLibrary_RCOSC</td>
<td>Application build configuration linked to Stack library for 32-kHz crystal-less device
configuration</td>
</tr>
<tr class="row-odd"><td>FlashROM_OAD_ImgB</td>
<td>OAD on-chip customer application FlashROM image</td>
</tr>
<tr class="row-even"><td>FlashROM_OAD_Offchip</td>
<td>OAD off-chip application FlashROM configuration</td>
</tr>
<tr class="row-odd"><td rowspan="2">Stack</td>
<td>FlashROM_Library</td>
<td>Stack library build configuration</td>
</tr>
<tr class="row-even"><td>FlashROM</td>
<td>Stack
image using protocol stack in ROM configuration</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Some of the build configurations above may be located in a separate
project for CCS, for example <code class="docutils literal"><span class="pre">simple_peripheral_cc2640r2lp_app_oad_offchip</span></code>.
However the principles of the table above can still be applied. Always
consult the <code class="docutils literal"><span class="pre">README.html</span></code> file of the specific sample application for
more information on it&#8217;s supported build configurations. Additionally,
refer to <a class="reference internal" href="#tbl-inc-developing-in-ccs-build-configs"><span class="std std-ref">Available CCS project build configurations</span></a></p>
</div>
</div>
<div class="section" id="converting-library-build-to-split-image">
<h4>Converting Library Build to Split Image<a class="headerlink" href="#converting-library-build-to-split-image" title="Permalink to this headline">¶</a></h4>
<p>All BLE-Stack 3.00.01 projects will support
improved ICall and the Library build configuration. However, not all
projects will have ICall in non-Library Build configuration.
In other words, not all projects will have a split application/stack
build configuration.</p>
<p>A split Application and Stack configuration is required for on-chip OAD
applications where only the stack or the application image is
planned to be upgraded. Library configuration only supports full
application + stack image off-chip OAD.</p>
<p>This section outlines how to convert an ICall Library
Project to a split application and stack project.</p>
<div class="section" id="application-side-iar">
<h5>Application Side (IAR)<a class="headerlink" href="#application-side-iar" title="Permalink to this headline">¶</a></h5>
<ol class="arabic">
<li><p class="first">Select the Application Project as Active Project</p>
<blockquote>
<div><p>Delete <code class="docutils literal"><span class="pre">StackLibrary</span></code> IDE Folder or exclude library file
from build.</p>
</div></blockquote>
</li>
<li><p class="first">Open Project Properties</p>
<blockquote>
<div><p>Various ways to do this:</p>
<blockquote>
<div><ul class="simple">
<li>Right Click on Project &gt; Options</li>
<li>From Toolbar : Project &gt; Options</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first">Go to C/C++ Compiler Options, Preprocessor tab</p>
<blockquote>
<div><p>Select C/C++ Compiler from the Category List</p>
<p>Select Preprocessor Tab</p>
</div></blockquote>
</li>
<li><p class="first">Remove <code class="docutils literal"><span class="pre">STACK_LIBRARY</span></code> Symbol</p>
<blockquote>
<div><p>Under <code class="docutils literal"><span class="pre">Defined</span> <span class="pre">Symbols</span></code> remove <code class="docutils literal"><span class="pre">STACK_LIBRARY</span></code></p>
</div></blockquote>
</li>
<li><p class="first">Go to Linker Options, Config Tab</p>
<blockquote>
<div><p>Select Linker from the Category List</p>
<p>Select Config tab in the Window</p>
</div></blockquote>
</li>
<li><p class="first">Apply the following changes:</p>
<blockquote>
<div><ul>
<li><dl class="first docutils">
<dt>Linker configuration file:</dt>
<dd><div class="first highlight-none"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span>$SRC_EX$/common/cc26xx/iar/cc26xx_app.icf
</pre></div>
</td></tr></table></div>
<p>Instead of</p>
<div class="last highlight-none"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span>$SRC_EX$/common/cc26xx/iar/cc26xx_app_and_stack.icf
</pre></div>
</td></tr></table></div>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Configuration file symbol definitions:</dt>
<dd><div class="first highlight-none"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span>CC2650=2
</pre></div>
</td></tr></table></div>
<p>Remove</p>
<div class="last highlight-none"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span>FLASH_ROM_BUILD=2
</pre></div>
</td></tr></table></div>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">Go to Linker Options, Library Tab</p>
<blockquote>
<div><p>Select Linker from the Category List</p>
<p>Select Library tab in the Window</p>
</div></blockquote>
</li>
<li><p class="first">Modify Additional Linker Library Paths</p>
<blockquote>
<div><p>Change Additional Libraries text field to use:</p>
<blockquote>
<div><div class="highlight-none"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span>$ROM$\ble_rom_releases\cc26xx_r2\Final_Release\common_r2.symbols
</pre></div>
</td></tr></table></div>
</div></blockquote>
<p>Instead of:</p>
<blockquote>
<div><div class="highlight-none"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span>$ROM$\ble_rom_releases\cc26xx_r2\Final_Release\ble_r2.symbols
</pre></div>
</td></tr></table></div>
</div></blockquote>
<p>Lastly, remove:</p>
<blockquote>
<div><div class="highlight-none"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span>$TI_RTOS_DRIVERS_BASE$\ti\drivers\rf\lib\rf_singleMode_cc26x0r2.aem3
</pre></div>
</td></tr></table></div>
</div></blockquote>
</div></blockquote>
<p>Pre-Modifications:</p>
<div class="highlight-none"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span></span>$ROM$\ble_rom_releases\cc26xx_r2\Final_Release\ble_r2.symbols
$CC26XXWARE$\driverlib\bin\iar\driverlib.lib
$TI_RTOS_KERNEL$\packages\ti\dpl\lib\dpl_cc26x0r2.aem3
$TI_RTOS_DRIVERS_BASE$\ti\drivers\lib\drivers_cc26x0r2.aem3
$TI_RTOS_DRIVERS_BASE$\ti\drivers\rf\lib\rf_singleMode_cc26x0r2.aem3
$TI_RTOS_DRIVERS_BASE$\ti\display\lib\display.aem3
</pre></div>
</td></tr></table></div>
<p>Post-Modifications:</p>
<div class="highlight-none"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span>$ROM$\ble_rom_releases\cc26xx_r2\Final_Release\common_r2.symbols
$CC26XXWARE$\driverlib\bin\iar\driverlib.lib
$TI_RTOS_KERNEL$\packages\ti\dpl\lib\dpl_cc26x0r2.aem3
$TI_RTOS_DRIVERS_BASE$\ti\drivers\lib\drivers_cc26x0r2.aem3
$TI_RTOS_DRIVERS_BASE$\ti\display\lib\display.aem3
</pre></div>
</td></tr></table></div>
</li>
<li><p class="first">Go to Linker Options, Extra Options</p>
<blockquote>
<div><p>Select Linker from the Category List</p>
<p>Select Extra Options tab in the Window</p>
</div></blockquote>
</li>
<li><p class="first">Remove <code class="docutils literal"><span class="pre">lib_linker.cmd</span></code></p>
<blockquote>
<div><p>The window should have the following content after removal</p>
<div class="highlight-none"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span>--keep __vector_table
-f $PROJ_DIR$\..\config\configPkg\linker.cmd
-f $PROJ_DIR$\..\config\iar_boundary.xcl
</pre></div>
</td></tr></table></div>
</div></blockquote>
</li>
</ol>
</div>
<div class="section" id="stack-side-iar">
<h5>Stack Side (IAR)<a class="headerlink" href="#stack-side-iar" title="Permalink to this headline">¶</a></h5>
<ol class="arabic">
<li><p class="first">Select the Stack Project as Active Project</p>
</li>
<li><p class="first">Open Project Properties</p>
<blockquote>
<div><p>Various ways to do this:</p>
<blockquote>
<div><ul class="simple">
<li>Right Click on Project &gt; Options</li>
<li>From Toolbar : Project &gt; Options</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first">Go to General Options, Output Tab</p>
<blockquote>
<div><p>Select General Options from the Category List</p>
<p>Select the Output tab</p>
</div></blockquote>
</li>
<li><p class="first">Select <code class="docutils literal"><span class="pre">Executable</span></code> for Output File</p>
<blockquote>
<div><p>Select the <code class="docutils literal"><span class="pre">Executable</span></code> Radio Button under Output File.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This will reset Debugger Settings!</p>
</div>
</div></blockquote>
</li>
<li><p class="first">Go to C/C++ Compiler Options, Preprocessor tab</p>
<blockquote>
<div><p>Select C/C++ Compiler from the Category List</p>
<p>Select Preprocessor Tab</p>
</div></blockquote>
</li>
<li><p class="first">Remove <code class="docutils literal"><span class="pre">STACK_LIBRARY</span></code> Symbol</p>
<blockquote>
<div><p>Under <code class="docutils literal"><span class="pre">Defined</span> <span class="pre">Symbols</span></code> remove <code class="docutils literal"><span class="pre">STACK_LIBRARY</span></code></p>
</div></blockquote>
</li>
<li><p class="first">Go to Build Options</p>
<blockquote>
<div><p>Select Build Options from Category List</p>
</div></blockquote>
</li>
<li><p class="first">Add Boundary Tool to Post Build</p>
<blockquote>
<div><p>This tool hands information to the Application regarding Stack Entry Point.</p>
<p>Add the following to Post_Build command line:</p>
<div class="highlight-console"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="go">&quot;$TOOLS_BLE$/frontier/frontier.exe&quot; iar &quot;$PROJ_DIR$/$CONFIG_NAME$/List/simple_peripheral_cc2640r2lp_stack.map&quot; &quot;$PROJ_DIR$/../config/iar_boundary.bdef&quot; &quot;$PROJ_DIR$/../config/iar_boundary.xcl&quot;</span>
</pre></div>
</td></tr></table></div>
</div></blockquote>
</li>
<li><p class="first">Go to Linker Options, Config Tab</p>
<blockquote>
<div><p>Select Linker from the Category List</p>
<p>Select Config tab in the Window</p>
</div></blockquote>
</li>
<li><p class="first">Add <code class="docutils literal"><span class="pre">lib_linker.cmd</span></code></p>
<blockquote>
<div><p>This tool resolves undefined rom function references.</p>
<p>Select <code class="docutils literal"><span class="pre">Use</span> <span class="pre">command</span> <span class="pre">line</span> <span class="pre">options</span></code></p>
<p>Enter the following into the Command Line Options Textfield</p>
<div class="highlight-none"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span>-f $PROJ_DIR$/../config/lib_linker.cmd
</pre></div>
</td></tr></table></div>
</div></blockquote>
</li>
<li><p class="first">Reconfigure Debugger Settings</p>
<blockquote>
<div><p>Use XDS110 for the <a class="reference external" href="http://www.ti.com.cn/tool/launchxl-cc2640r2">CC2640R2 Launchpad</a>. Use the application project as reference.</p>
</div></blockquote>
</li>
</ol>
<p>At this point, you will have a functional ICall Non-Library build of the project.</p>
</div>
</div>
<div class="section" id="standard-project-task-hierarchy">
<span id="sec-inc-architecture-standard-project-task-hierarchy"></span><h4>Standard Project Task Hierarchy<a class="headerlink" href="#standard-project-task-hierarchy" title="Permalink to this headline">¶</a></h4>
<p>Considering the simple_peripheral project as an example, these tasks are listed
by priority. A higher task number corresponds to a higher priority task:</p>
<ul class="simple">
<li>Priority 5: Bluetooth low energy protocol stack task (must be highest priority)</li>
<li>Priority 3: GapRole task (peripheral role)</li>
<li>Priority 1: Application task (simple_peripheral)</li>
</ul>
<p><a class="reference internal" href="#sec-tirtos-overview"><span class="std std-ref">TI-RTOS Overview</span></a> introduces TI-RTOS tasks.
<a class="reference internal" href="../ble-stack/index.html#sec-ble-stack-overview"><span class="std std-ref">Overview</span></a> describes interfacing with the Bluetooth low
energy protocol stack. <a class="reference internal" href="../ble-stack/index.html#sec-gaprole-gaproletask"><span class="std std-ref">GAPRole Task</span></a> describes the GapRole
task. <a class="reference internal" href="../ble-stack/index.html#start-up-in-main"><span class="std std-ref">Pre-main initialization</span></a> describes the application task.</p>
</div>
</div>
<div class="section" id="directory-structure">
<h3>Directory Structure<a class="headerlink" href="#directory-structure" title="Permalink to this headline">¶</a></h3>
<p>The default install location is: <em>C:\ti\simplelink_cc2640r2_sdk_x_xx_xx_xx</em>.</p>
<p>The SDK installs to this location by default. For the purposes of this document,
consider the above path to the BLE-Stack root directory; it will be omitted. All
paths will be relative to the BLE-Stack root directory. Opening up the root
install directory shows the new parent folders within the SDK, as shown in
<a class="reference internal" href="#tbl-root-folder"><span class="std std-numref">Table 3.</span></a></p>
<table border="1" class="docutils" id="id20">
<span id="tbl-root-folder"></span><caption><span class="caption-number">Table 3. </span><span class="caption-text">SDK root folders</span><a class="headerlink" href="#id20" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="38%" />
<col width="62%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">BLE-Stack 3.00.01 folders</th>
<th class="head">Purpose</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>docs\</td>
<td>The docs directory now contains all relevant
documents included with the CC2640R2F SDK.
Refer to the Documentation Overview master page.</td>
</tr>
<tr class="row-odd"><td>examples\</td>
<td>The CC2640R2F SDK includes ble examples as well as
TI-RTOS kernel and TI-RTOS driver examples.</td>
</tr>
<tr class="row-even"><td>kernel\</td>
<td>The TI-RTOS kernel is now included with the
CC2640R2F SDK.</td>
</tr>
<tr class="row-odd"><td>source\</td>
<td>The source\ directory include source for
BLE-Stack, TI-RTOS kernel and drivers, and various
middleware modules.</td>
</tr>
<tr class="row-even"><td>tools\</td>
<td>Tools such as BTool</td>
</tr>
</tbody>
</table>
<div class="section" id="examples-folder">
<h4>Examples Folder<a class="headerlink" href="#examples-folder" title="Permalink to this headline">¶</a></h4>
<p>The examples\ folder contains example source files for the BLE-Stack, TI-RTOS
kernel, and TI-RTOS drivers. All the source code supporting the SimpleLink CC2640R2 SDK examples
can be found at *examples\rtos\CC2640R2_LAUNCHXL\. Examples for each
product can be found within their respective folders and are accessible via
various means as shown in <a class="reference internal" href="#tbl-sdk-examples"><span class="std std-ref">Examples available for the CC2640R2F platform</span></a>.</p>
<table border="1" class="docutils" id="id21">
<span id="tbl-sdk-examples"></span><caption><span class="caption-number">Table 4. </span><span class="caption-text">Examples available for the CC2640R2F platform</span><a class="headerlink" href="#id21" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="21%" />
<col width="26%" />
<col width="53%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Type of examples</th>
<th class="head">Example subdirectory</th>
<th class="head">How to open the examples</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>BLE-Stack</td>
<td>blestack\</td>
<td><div class="first last line-block">
<div class="line">Imported via TI Resource Explorer</div>
<div class="line">Opened as existing IAR projects</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>TI-RTOS Kernel</td>
<td>sysbios\</td>
<td><div class="first last line-block">
<div class="line"><a class="reference external" href="http://processors.wiki.ti.com/index.php/Resource_Explorer">Import TI-RTOS driver examples for CCS</a></div>
<div class="line"><a class="reference external" href="http://processors.wiki.ti.com/index.php/Creating_TI-RTOS_Applications_in_IAR_Embedded_Workbench">Import TI-RTOS driver examples for IAR</a></div>
</div>
</td>
</tr>
<tr class="row-even"><td>TI-RTOS Drivers</td>
<td>drivers\</td>
<td><div class="first last line-block">
<div class="line"><a class="reference external" href="http://processors.wiki.ti.com/index.php/Resource_Explorer">Import TI-RTOS driver examples for CCS</a></div>
<div class="line"><a class="reference external" href="http://processors.wiki.ti.com/index.php/Creating_TI-RTOS_Applications_in_IAR_Embedded_Workbench">Import TI-RTOS driver examples for IAR</a></div>
</div>
</td>
</tr>
</tbody>
</table>
<p>For TI-RTOS Kernel and TI-RTOS driver examples, see the linked documentation.
To help select a specific BLE example, see <a class="reference internal" href="get-started/get-started.html#tbl-sdk-ble-examples"><span class="std std-ref">BLE examples available for the CC2640R2F platform</span></a>. As with
previous BLE-Stack releases, each example contains a toolchain subdirectory for
CCS and IAR.</p>
<p>IAR examples are available as .eww projects whereas CCS project are imported.</p>
<p>See <a class="reference internal" href="get-started/get-started.html#tbl-sdk-ble-examples"><span class="std std-numref">Table 1.</span></a> for a list of examples supported by the SDK.</p>
</div>
<div class="section" id="source-folder">
<h4>Source Folder<a class="headerlink" href="#source-folder" title="Permalink to this headline">¶</a></h4>
<p>The source\ti\ folder contains libraries and source files for the BLE-Stack,
TI-RTOS drivers, and various shared modules. They can be found within their
respective folders as shown in <a class="reference internal" href="#tbl-sdk-source"><span class="std std-ref">CC2640R2F SDK&#8217;s source\ti\ directory</span></a>.</p>
<table border="1" class="docutils" id="id22">
<span id="tbl-sdk-source"></span><caption><span class="caption-number">Table 5. </span><span class="caption-text">CC2640R2F SDK&#8217;s source\ti\ directory</span><a class="headerlink" href="#id22" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="21%" />
<col width="26%" />
<col width="53%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">source\ti\</th>
<th class="head">subdirectory</th>
<th class="head">Purpose</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td colspan="2">blestack\</td>
<td>Root source directory for the BLE-Stack</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>blelib\</td>
<td>Prebuilt BLE-Stack libraries</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>boards\</td>
<td>Sample board files for use with BLE-Stack</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>common\</td>
<td>Linker, RTOS config, and middleware used by
the stack</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>config\</td>
<td>Symbol files for various stack builds and
configurations</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>controller\</td>
<td>Header files for the BLE controller layer</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>hal\</td>
<td>Hardware abstraction layer files for Stack</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>heapmgr\</td>
<td>BLE-Stack Heap Manager</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>host\</td>
<td>Header files for the BLE host layers</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>icall\</td>
<td>Source files for the ICall module</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>inc\</td>
<td>Header files used to interface with the
BLE-Stack</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>microstack\</td>
<td>Source files for the Micro BLE Stack</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>npi\</td>
<td>Source files for the both NPI modules</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>osal\</td>
<td>Source support files used by the BLE-Stack</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>profiles\</td>
<td>Sample BLE profile implementations</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>rom\</td>
<td>BLE-Stack ROM symbol file</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>services\</td>
<td>Miscellaneous support files</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>symbols\</td>
<td>ROM patch support files</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>target\</td>
<td>Board gateway folder</td>
</tr>
<tr class="row-odd"><td colspan="2">devices\</td>
<td>Support files from driverlib</td>
</tr>
<tr class="row-even"><td colspan="2">display\</td>
<td>Display module</td>
</tr>
<tr class="row-odd"><td colspan="2">drivers\</td>
<td>TI-RTOS drivers source and libraries</td>
</tr>
<tr class="row-even"><td colspan="2">grlib\</td>
<td>Graphics library (not used by BLE-Stack
examples)</td>
</tr>
<tr class="row-odd"><td colspan="2">mw\</td>
<td>Other middleware modules dependent on
TI-RTOS drivers</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="working-with-hex-and-binary-files">
<span id="sec-inc-architecture-working-with-hex-files"></span><h3>Working With Hex and Binary Files<a class="headerlink" href="#working-with-hex-and-binary-files" title="Permalink to this headline">¶</a></h3>
<p>BLE-Stack projects have project build configurations in which the application
and stack projects produce an Intel<sup>®</sup>-extended hex file in their
respective output folders. These hex files lack overlapping memory regions and
can be programmed individually with a flash programming tool, such as SmartRF
Flash Programmer 2. . To simplify the flash programming process, you can combine
the application and stack hex files into a super hex file manually or using
freely available tools.
Information on the <a class="reference external" href="https://en.wikipedia.org/wiki/Intel_HEX">Intel Hex standard</a>.</p>
<p>One example for creating the super hex file is with the IntelHex python script
hex_merge.py, available at <a class="reference external" href="https://launchpad.net/intelhex/+download">IntelHex launchpad</a>.
To merge the hex files, install Python<sup>®</sup> 2.7.x and add it to your system
path environment variables.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Note that when using any python script, you must use a compatible version
of Python. Refer to the tool documentation or contact the developer to
verify compatibility.</p>
</div>
<p>The following is an example usage to create a merged
simple_peripheral_cc2640r2lp.hex file consisting of the individual application
and stack hex files:</p>
<div class="highlight-console" id="lst-hexmerge-script"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="go">C:\Python27\Scripts&gt;python hexmerge.py \</span>
<span class="go">    -o .\simple_peripheral_cc2640r2lp_merged.hex \</span>
<span class="go">    -r 0000:1FFFF</span>
<span class="go">    simple_peripheral_cc2640r2lp_app.hex:0000:1FFFF</span>
<span class="go">    simple_peripheral_cc2640r2lp_stack.hex</span>
<span class="go">    --overlap=error</span>
</pre></div>
</td></tr></table></div>
<p>If conversion of the super hex to binary is desired, this can be accomplished
with the “hex2bin.py” or similar tools that support the hex standard.</p>
<div class="highlight-console"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="go">C:\Python27\Scripts&gt;python hex2bin.py \</span>
<span class="go">    simple_peripheral_cc2640r2lp_merged.hex \</span>
<span class="go">    simple_peripheral_cc2640r2lp_merged.bin</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="programming-internal-flash-with-the-rom-bootloader">
<h3>Programming Internal Flash with the ROM Bootloader<a class="headerlink" href="#programming-internal-flash-with-the-rom-bootloader" title="Permalink to this headline">¶</a></h3>
<p>The CC2640R2F internal flash memory can be programmed using the bootloader in the
ROM of the device. Both UART and SPI protocols are supported. For more details
on the programming protocol and requirements, see the Bootloader chapter of the
<a class="reference external" href="http://www.ti.com/lit/pdf/swcu117">CC26xx Technical Reference Manual</a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Because the ROM bootloader uses predefined DIO pins for internal flash
programming, allocate these pins in the layout of your board. For details on
the pins allocated to the bootloader based on the chip package type, see
<a class="reference external" href="http://www.ti.com/lit/pdf/swcu117">CC26xx Technical Reference Manual</a>.</p>
</div>
</div>
</div>
<div class="section" id="installing-blestack">
<span id="sec-ble-stack-install"></span><h2>Installing BLE-Stack 3.00.01<a class="headerlink" href="#installing-blestack" title="Permalink to this headline">¶</a></h2>
<p>The BLE-Stack 3.00.01 is a wireless component included as part of the SimpleLink CC2640R2 SDK. All path
and file references in this document assume that the SimpleLink CC2640R2 SDK is installed to the
default path (<strong>&lt;SDK_INSTALL_DIR&gt;</strong>).</p>
<p>TI recommends making a backup copy of the SimpleLink CC2640R2 SDK before to making any changes.
The BLE-Stack 3.00.01 uses paths relative to the SimpleLink CC2640R2 SDK and therefore is portable in
respect to any valid installation path for the SimpleLink CC2640R2 SDK.</p>
<div class="admonition attention">
<p class="first admonition-title">Attention</p>
<p class="last">Code Composer Studio creates a <em>dynamic</em> installation variable for a
discovered SimpleLink CC2640R2 SDK instances. For more information, see
<a class="reference internal" href="#sec-inc-developing-in-ccs-discover-ccs-products"><span class="std std-ref">Discovering CCS products</span></a>.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If installing the SimpleLink CC2640R2 SDK to a non-default path, do not exceed the maximum
length of the file system namepath. Actual paths may differ from the
figures.</p>
</div>
<p>SimpleLink CC2640R2 SDK also installs XDCTools if not already present. See the release
notes for required version numbers. Newer versions of tools may not be
compatible with this SDK release. Check the TI Bluetooth LE Wiki for the latest
supported tool versions.</p>
</div>
<div class="section" id="developing-with-ccs">
<span id="sec-developing-with-ccs"></span><h2>Developing with CCS<a class="headerlink" href="#developing-with-ccs" title="Permalink to this headline">¶</a></h2>
<div class="section" id="installing-code-composer-studio-ccs">
<h3>Installing Code Composer Studio (CCS)<a class="headerlink" href="#installing-code-composer-studio-ccs" title="Permalink to this headline">¶</a></h3>
<p>The CCS toolchain contains many features beyond the scope of this document.
More information and documentation can be found on the
<a class="reference external" href="http://www.ti.com/tool/CCSTUDIO">CCS Webpage</a>.</p>
<p>Check the BLE-Stack 3.00.01 release notes to see which CCS version to use and any
required workarounds. Object code produced by CCS may differ in size and
performance as compared to IAR produced object code.</p>
<p>The following procedure describes installing and configuring the correct version
of CCS and the necessary tools.</p>
<ol class="arabic">
<li><p class="first">Install Code Composer Studio for ARM</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference external" href="http://processors.wiki.ti.com/index.php/Download_CCS">Download Code Composer Studio</a></li>
<li>Start the installation process and accept the license agreement. It is
recommended to install CCS in its default location.</li>
<li>In the <strong>Processor Support</strong> section, select <strong>SimpleLink CC13xx and
CC26xx Wireless MCUs</strong>.</li>
<li>Under the <strong>Debug Probes</strong> section, CCS will install support for <strong>TI XDS
Debug Probe Support</strong>. This option supports the XDS110 debugger.</li>
<li>Start the installation by selecting <strong>Finish</strong>.</li>
</ul>
<div class="admonition attention">
<p class="first admonition-title">Attention</p>
<p class="last">The version required is stated in the release notes.</p>
</div>
</div></blockquote>
</li>
<li><p class="first">Verify ARM Compiler Tools version</p>
<blockquote>
<div><ul class="simple">
<li>If needed, the CCS and ARM compiler versions can be verified by going to
into <strong>Help</strong> -&gt; <strong>About Code Composer Studio</strong>. Under the <strong>Installation
Details</strong> button, you can determine the <strong>ARM Compiler Tools</strong> version.
Please ensure this version satisfies the version requirements as stated in
the release notes.</li>
<li>If an update is required, refer to <a class="reference internal" href="#sec-install-ti-arm-compiler"><span class="std std-ref">Installing a Specific TI ARM Compiler</span></a>
for the procedure to install the required TI ARM Compiler version.</li>
</ul>
</div></blockquote>
</li>
</ol>
</div>
<div class="section" id="installing-a-specific-ti-arm-compiler">
<span id="sec-install-ti-arm-compiler"></span><h3>Installing a Specific TI ARM Compiler<a class="headerlink" href="#installing-a-specific-ti-arm-compiler" title="Permalink to this headline">¶</a></h3>
<p>To install a specific TI ARM Compiler, refer to the following steps and
<a class="reference internal" href="#fig-verify-ccs-compiler"><span class="std std-numref">Figure 7.</span></a></p>
<ol class="arabic simple">
<li><strong>Help</strong> -&gt; <strong>Install New Software</strong></li>
<li>Under the <strong>Work with:</strong> drop-down list, select <strong>Code Generation Tools
Update</strong></li>
<li>Uncheck <strong>Show only the latest versions of available software</strong></li>
<li>Expand <strong>TI Compiler Update</strong>.</li>
<li>Select the desired ARM Compiler Tools version as stated in the release notes.</li>
<li>Press <strong>Next</strong> to complete the installation. You may have to restart CCS
afterwards.</li>
</ol>
<div class="figure align-center" id="id23">
<span id="fig-verify-ccs-compiler"></span><a class="reference internal image-reference" href="../_images/ti-arm-compiler-version.jpg"><img alt="../_images/ti-arm-compiler-version.jpg" src="../_images/ti-arm-compiler-version.jpg" style="width: 400px;" /></a>
<p class="caption"><span class="caption-number">Figure 7. </span><span class="caption-text">TI ARM Compiler Version in Code Composer Studio</span></p>
</div>
</div>
<div class="section" id="importing-ccs-projects">
<h3>Importing CCS projects<a class="headerlink" href="#importing-ccs-projects" title="Permalink to this headline">¶</a></h3>
<p>This section describes how to import and build an existing project and references
the simple_peripheral project. All of the BLE-Stack 3.00.01 projects included in the
development kit have a similar structure.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Before importing a BLE-Stack 3.00.01 project, CCS must discover the SimpleLink CC2640R2 SDK. Install
the SimpleLink CC2640R2 SDK before <em>opening</em> or after <em>restarting</em> CCS.</p>
</div>
<ol class="arabic">
<li><p class="first">Open the CCS IDE from the Start Menu.</p>
</li>
<li><p class="first">Create a workspace.</p>
<blockquote>
<div><div class="admonition attention">
<p class="first admonition-title">Attention</p>
<p class="last">Ensure that the CCS workspace path does not contain a whitespace.</p>
</div>
</div></blockquote>
</li>
<li><p class="first">Import a CCS Project</p>
<blockquote>
<div><ul>
<li><p class="first">Select <strong>Project</strong> -&gt; <strong>Import CCS Projects...</strong></p>
</li>
<li><p class="first">Select search directory: <em>&lt;SDK_INSTALL_DIR&gt;\examples\rtos\CC2640R2_LAUNCHXL\blestack\simple_peripheral\tirtos\ccs</em></p>
</li>
<li><p class="first">CCS discovers several projects, each having a unique build configuration.</p>
<blockquote>
<div><ul class="simple">
<li>For this example, select <strong>simple_peripheral_cc2640r2lp_app</strong> and <strong>simple_peripheral_cc2640r2lp_stack_library</strong></li>
</ul>
</div></blockquote>
</li>
<li><p class="first">Select <strong>Finish</strong></p>
</li>
</ul>
<div class="admonition caution">
<p class="first admonition-title">Caution</p>
<p class="last">Similar as with all other TI projects, CCS needs to <em>discover</em> the SimpleLink CC2640R2 SDK
before BLE-Stack 3.00.01 projects can be imported.</p>
</div>
</div></blockquote>
</li>
<li><p class="first">Click Finish to import (see <a class="reference internal" href="#fig-ccs-import-projects"><span class="std std-numref">Figure 8.</span></a>).</p>
<blockquote>
<div><div class="figure align-center" id="id24">
<span id="fig-ccs-import-projects"></span><a class="reference internal image-reference" href="../_images/image32.jpeg"><img alt="../_images/image32.jpeg" src="../_images/image32.jpeg" style="width: 75%;" /></a>
<p class="caption"><span class="caption-number">Figure 8. </span><span class="caption-text">Import CCS Projects</span></p>
</div>
</div></blockquote>
</li>
</ol>
</div>
<div class="section" id="discovering-ccs-products">
<span id="sec-inc-developing-in-ccs-discover-ccs-products"></span><h3>Discovering CCS products<a class="headerlink" href="#discovering-ccs-products" title="Permalink to this headline">¶</a></h3>
<p>Code Composer Studio automatically discovers the SimpleLink CC2640R2 SDK if it installed in its
default installation directory (<code class="docutils literal"><span class="pre">c:/ti</span></code>). Once discovered by CCS, it defines a
build environment variable named <code class="docutils literal"><span class="pre">COM_TI_SIMPLELINK_CC2640R2_SDK_INSTALL_DIR</span></code>
which is used by BLE-Stack 3.00.01 projects.</p>
<p>If a BLE-Stack 3.00.01 project is imported from a path other than what was specified
during the SimpleLink CC2640R2 SDK installation, the <code class="docutils literal"><span class="pre">COM_TI_SIMPLELINK_CC2640R2_SDK_INSTALL_DIR</span></code>
variable must be redefined after the import proceeding at a project-by-project
basis.</p>
<p>To redefine this variable:</p>
<ol class="arabic">
<li><p class="first">Open the CCS project&#8217;s properties (<strong>Project</strong> -&gt; <strong>Properties</strong>)</p>
</li>
<li><p class="first">Navigate to <strong>Resource</strong> -&gt; <strong>Linked Resources</strong> and <em>edit</em>
<code class="docutils literal"><span class="pre">COM_TI_SIMPLELINK_CC2640R2_SDK_INSTALL_DIR</span></code> and have it point to your
imported root directory location.</p>
<div class="figure align-center" id="id25">
<span id="fig-inc-developing-in-ccs-redefine-ccs-linked-resources"></span><a class="reference internal image-reference" href="../_images/redefine-ccs-linked-resources.jpg"><img alt="../_images/redefine-ccs-linked-resources.jpg" src="../_images/redefine-ccs-linked-resources.jpg" style="width: 75%;" /></a>
<p class="caption"><span class="caption-number">Figure 9. </span><span class="caption-text">Redefining <code class="docutils literal"><span class="pre">COM_TI_SIMPLELINK_CC2640R2_SDK_INSTALL_DIR</span></code></span></p>
</div>
</li>
</ol>
</div>
<div class="section" id="blestack-ccs-project-build-configurations">
<h3>BLE-Stack 3.00.01 CCS project build configurations<a class="headerlink" href="#blestack-ccs-project-build-configurations" title="Permalink to this headline">¶</a></h3>
<div class="sidebar">
<p class="first sidebar-title">CCS Project Explorer</p>
<div class="last figure align-center" id="id26">
<span id="fig-ccs-project-explorer"></span><img alt="../_images/image33.jpeg" src="../_images/image33.jpeg" />
<p class="caption"><span class="caption-number">Figure 10. </span><span class="caption-text">CCS Project Explorer</span></p>
</div>
</div>
<p>This and all BLE-Stack 3.00.01 project workspaces contain various projects and build
configurations as shown in <a class="reference internal" href="#tbl-inc-developing-in-ccs-build-configs"><span class="std std-numref">Table 6.</span></a>
*_StackLibrary build configurations build the stack as a library as
described in <a class="reference internal" href="#sec-inc-architecture-stack-image-as-a-library"><span class="std std-ref">Stack Library Configuration (_stack_library)</span></a>.</p>
<p>Click the project name in the file explorer to select the project as the active
project. In <a class="reference internal" href="#fig-ccs-project-explorer"><span class="std std-numref">Figure 10.</span></a>, the application is selected as
the active project. Each of these projects produces a separate, downloadable
image.</p>
<p>The simple_peripheral sample project is the primary sample application for the
description of a generic application in this guide. The simple_peripheral
project implements a basic Bluetooth low energy peripheral device including a
GATT server with GATT services. This project can be used as a framework for
developing peripheral-role applications.</p>
<table border="1" class="docutils" id="id27">
<span id="tbl-inc-developing-in-ccs-build-configs"></span><caption><span class="caption-number">Table 6. </span><span class="caption-text">Available CCS project build configurations</span><a class="headerlink" href="#id27" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="10%" />
<col width="24%" />
<col width="22%" />
<col width="44%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Project type</th>
<th class="head">Project naming convention</th>
<th class="head">Project&#8217;s build configuration</th>
<th class="head">Compatible project complement</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td rowspan="5">Application</td>
<td rowspan="3"><code class="docutils literal"><span class="pre">*_cc2640r2lp_app</span></code></td>
<td>FlashROM</td>
<td><code class="docutils literal"><span class="pre">*_cc2640r2lp_stack</span></code></td>
</tr>
<tr class="row-odd"><td>FlashROM_StackLibrary</td>
<td><code class="docutils literal"><span class="pre">*_cc2640r2lp_stack_library</span></code></td>
</tr>
<tr class="row-even"><td>FlashROM_StackLibrary_RCOSC</td>
<td><code class="docutils literal"><span class="pre">*_cc2640r2lp_stack_library</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">*_cc2640r2lp_app_oad_onchip</span></code></td>
<td>FlashROM_OAD_ImgB</td>
<td><code class="docutils literal"><span class="pre">*_cc2640r2lp_stack</span></code> with FlashROM configuration</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">*_cc2640r2lp_app_oad_offchip</span></code></td>
<td>FlashROM_OAD_Offchip</td>
<td><code class="docutils literal"><span class="pre">*_cc2640r2lp_stack</span></code> with FlashROM configuration</td>
</tr>
<tr class="row-odd"><td rowspan="2">Stack</td>
<td><code class="docutils literal"><span class="pre">*_cc2640r2lp_stack_library</span></code></td>
<td>FlashROM_Library</td>
<td><code class="docutils literal"><span class="pre">*_cc2640r2lp_app</span></code> with FlashROM_StackLibrary configuration</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">*_cc2640r2lp_stack</span></code></td>
<td>FlashROM</td>
<td><code class="docutils literal"><span class="pre">*_cc2640r2lp_app</span></code> with FlashROM configuration</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="compiling-and-download">
<h3>Compiling and Download<a class="headerlink" href="#compiling-and-download" title="Permalink to this headline">¶</a></h3>
<p>For all build configurations, the stack project should always be built before
the application project.</p>
<p>For projects where the stack is built as a <strong>library</strong>:</p>
<blockquote>
<div><ol class="arabic">
<li><p class="first">Build the stack library project.</p>
<blockquote>
<div><ul class="simple">
<li>Set the stack project as the active project.</li>
<li>Select <strong>Project</strong> -&gt; <strong>Build All</strong> to build the stack project.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">Build the application project.</p>
<blockquote>
<div><ul class="simple">
<li>Set the application project as the active project.</li>
<li>Select <strong>Project -&gt; Build All</strong> to build the application project.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">Load the whole application</p>
<blockquote>
<div><ul class="simple">
<li>Select <strong>Run</strong> -&gt; <strong>Debug</strong> to download the application</li>
</ul>
</div></blockquote>
</li>
</ol>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Application project that consume the stack in a library form will not
have hard defined image boundaries.</p>
<p class="last">After the initial build, if the stack project is not modified, only the
application project needs to be rebuilt.</p>
</div>
</div></blockquote>
<p>For projects where the stack and application are <strong>split images</strong> (not a library):</p>
<blockquote>
<div><ol class="arabic">
<li><p class="first">Build the stack project.</p>
<blockquote>
<div><ul class="simple">
<li>Set the stack project as the active project.</li>
<li>Select <strong>Project</strong> -&gt; <strong>Build All</strong> to build the stack project.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">Build the application project.</p>
<blockquote>
<div><ul class="simple">
<li>Set the application project as the active project.</li>
<li>Select <strong>Project -&gt; Build All</strong> to build the application project.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">Load the stack project</p>
<blockquote>
<div><ul class="simple">
<li>Set the stack project as the active project.</li>
<li>Select <strong>Run</strong> -&gt; <strong>Debug</strong> to download the stack</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">Load the application project</p>
<blockquote>
<div><ul class="simple">
<li>Set the application project as the active project.</li>
<li>Select <strong>Run</strong> -&gt; <strong>Debug</strong> to download the application</li>
</ul>
</div></blockquote>
</li>
</ol>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The stack project defines the flash and RAM boundary parameters used by
the application project. Any modifications to the stack project require
a rebuild of the stack project, followed by a rebuild of the application
project to use the new boundary settings. See <a class="reference internal" href="#sec-fontier-tool"><span class="std std-ref">Frontier Tool Operation</span></a>.</p>
<p class="last">After the initial build, if the stack project is not modified, only the
application project needs to be rebuilt.</p>
</div>
</div></blockquote>
<div class="admonition caution">
<p class="first admonition-title">Caution</p>
<p class="last">Do not modify the CPU Variant in the project settings. All sample projects
are configured with a CPU type, and changing this setting (that is, from
CC2640R2F) may result in build errors.</p>
</div>
<p>Sample applications that implement the Over the Air Download (OAD) firmware
update capability require the Boot Image Manager (BIM) project to be built.
Refer to the <a class="reference internal" href="../oad/oad.html#sec-oad"><span class="std std-ref">Over the Air Download (OAD)</span></a> section for more details.</p>
</div>
<div class="section" id="accessing-preprocessor-symbols">
<span id="sec-developing-with-ccs-accessing-preprocessor-symbols"></span><h3>Accessing Preprocessor Symbols<a class="headerlink" href="#accessing-preprocessor-symbols" title="Permalink to this headline">¶</a></h3>
<p>Various C preprocessor symbols may need to be set or adjusted at the project
level. The following procedure describes how to access and modify preprocessor
symbols.</p>
<ol class="arabic simple">
<li>Open <strong>Project Properties</strong></li>
<li>Navigate to <strong>Build</strong> -&gt; <strong>ARM Compiler</strong> -&gt; <strong>Predefined Symbols</strong></li>
<li>Use the buttons highlighted in <a class="reference internal" href="#fig-ccs-defines-box"><span class="std std-numref">Figure 11.</span></a> to add, delete,
or edit a preprocessor.</li>
</ol>
<div class="figure align-center" id="id28">
<span id="fig-ccs-defines-box"></span><a class="reference internal image-reference" href="../_images/image42.jpeg"><img alt="../_images/image42.jpeg" src="../_images/image42.jpeg" style="width: 75%;" /></a>
<p class="caption"><span class="caption-number">Figure 11. </span><span class="caption-text">CCS Predefined Symbols</span></p>
</div>
</div>
<div class="section" id="accessing-linker-symbols">
<span id="sec-developing-with-ccs-accessing-linker-symbols"></span><h3>Accessing Linker Symbols<a class="headerlink" href="#accessing-linker-symbols" title="Permalink to this headline">¶</a></h3>
<p>Linker symbols may need to be set or adjusted at the project level in order to
control the memory layout of the generated image.
The following procedure describes how to access and modify linker
symbols.</p>
<ol class="arabic simple">
<li>Open <strong>Project Properties</strong></li>
<li>Navigate to <strong>Build</strong> -&gt; <strong>ARM Linker</strong> -&gt; <strong>Command File Preprocessing</strong></li>
<li>Use the buttons highlighted in <a class="reference internal" href="#fig-ccs-linker-defines-box"><span class="std std-numref">Figure 12.</span></a> to add,
delete, or edit a linker symbol.</li>
</ol>
<div class="figure align-center" id="id29">
<span id="fig-ccs-linker-defines-box"></span><a class="reference internal image-reference" href="../_images/ccs_linker_opts.png"><img alt="../_images/ccs_linker_opts.png" src="../_images/ccs_linker_opts.png" style="width: 75%;" /></a>
<p class="caption"><span class="caption-number">Figure 12. </span><span class="caption-text">CCS Linker Symbols</span></p>
</div>
</div>
<div class="section" id="resetting-the-device-in-ccs">
<h3>Resetting the CC2640R2F in CCS<a class="headerlink" href="#resetting-the-device-in-ccs" title="Permalink to this headline">¶</a></h3>
<p>Select Board Reset from the reset menu.</p>
<div class="figure align-center" id="id30">
<a class="reference internal image-reference" href="../_images/image183.jpeg"><img alt="../_images/image183.jpeg" src="../_images/image183.jpeg" style="width: 75%;" /></a>
<p class="caption"><span class="caption-number">Figure 13. </span><span class="caption-text">CCS Board Reset</span></p>
</div>
</div>
<div class="section" id="additional-training-and-support-for-ccs">
<h3>Additional training and support for CCS<a class="headerlink" href="#additional-training-and-support-for-ccs" title="Permalink to this headline">¶</a></h3>
<p>For additional training and support with Code Composer Studio, refer to:
<a class="reference external" href="http://processors.wiki.ti.com/index.php/Category:Code_Composer_Studio_v6">Code Composer Studio Wiki</a>
<a class="reference external" href="http://processors.wiki.ti.com/index.php/Category:CCSv6_Training">Code Composer Studio Training</a></p>
</div>
</div>
<div class="section" id="developing-with-iar">
<span id="sec-developing-with-iar"></span><h2>Developing with IAR<a class="headerlink" href="#developing-with-iar" title="Permalink to this headline">¶</a></h2>
<div class="section" id="installing-iar">
<h3>Installing IAR<a class="headerlink" href="#installing-iar" title="Permalink to this headline">¶</a></h3>
<p>The IAR toolchain contains many features beyond the scope of this document.
More information and documentation can be found at <a class="reference external" href="www.iar.com">IAR.com</a>.</p>
<p>Check the BLE-Stack 3.00.01 release notes to see which IAR version to use and any
required workarounds. Object code produced by IAR may differ in size and
performance as compared to CCS produced object code.</p>
<p>The following procedure describes installing and configuring the correct version
of IAR and the necessary tools.</p>
<ol class="arabic">
<li><p class="first">Install IAR Embedded Workbench for ARM</p>
<blockquote>
<div><p><a class="reference external" href="https://www.iar.com/iar-embedded-workbench/partners/texas-instruments/ti-wireless/">Download and install IAR EW ARM</a></p>
<p>To get IAR, choose one of the following methods:</p>
<blockquote>
<div><ul class="simple">
<li>Download the IAR Embedded Workbench 30-Day Evaluation Edition –
This version of IAR is free, has full functionality, and
includes all of the standard features. The size-limited
Kickstart evaluation option is not compatible with this SDK.</li>
<li>Purchase the full-featured version of IAR Embedded Workbench – For
complete BLE application development using the CC2640R2F, TI
recommends purchasing the complete version of IAR without any
restrictions. You can find the information on purchasing the complete
version of <a class="reference external" href="https://www.iar.com/buy">IAR</a>.</li>
</ul>
</div></blockquote>
<div class="admonition attention">
<p class="first admonition-title">Attention</p>
<p class="last">The version required is stated in the release notes.
Opening IAR project files with a previous version of IAR may cause
project file corruption.</p>
</div>
</div></blockquote>
</li>
<li><p class="first">Show Build Messages</p>
<blockquote>
<div><p>TI recommends showing all the build output messages for full verbosity
during building. To do this, go to <strong>Tools</strong> -&gt; <strong>Options</strong> and set
<strong>Show Build Messages</strong> to <strong>All</strong>
(see <a class="reference internal" href="#fig-show-all-build-messages"><span class="std std-numref">Figure 14.</span></a>)</p>
<div class="figure align-center" id="id31">
<span id="fig-show-all-build-messages"></span><img alt="../_images/image15.png" src="../_images/image15.png" />
<p class="caption"><span class="caption-number">Figure 14. </span><span class="caption-text">Show All Build Messages in IAR</span></p>
</div>
</div></blockquote>
</li>
</ol>
</div>
<div class="section" id="opening-iar-projects">
<h3>Opening IAR Projects<a class="headerlink" href="#opening-iar-projects" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">TI-RTOS driver and kernel examples are imported for IAR rather than supplied
as pre-configured IAR workspace files. Instructions on how to create these
projects are found here: <a class="reference external" href="http://processors.wiki.ti.com/index.php/Creating_TI-RTOS_Applications_in_IAR_Embedded_Workbench">Creating TI-RTOS (driver/kernel) Applications in IAR Embedded Workbench</a></p>
</div>
<p>This section describes how to open and build an existing project and references
the simple_peripheral project. All of the BLE-Stack 3.00.01 projects included in the
development kit have a similar structure.</p>
<ol class="arabic">
<li><p class="first">Open the IAR Embedded Workbench IDE from the Start Menu.</p>
</li>
<li><p class="first">Open an IAR workspace project: <strong>File</strong> -&gt; <strong>Open</strong> -&gt; <strong>Workspace...</strong></p>
<blockquote>
<div><ul class="simple">
<li>For this example, select
<em>&lt;SDK_INSTALL_DIR&gt;\examples\rtos\CC2640R2_LAUNCHXL\blestack\simple_peripheral\tirtos\iar\simple_peripheral.eww</em></li>
</ul>
</div></blockquote>
</li>
</ol>
<div class="sidebar">
<p class="first sidebar-title">IAR Workspace Pane</p>
<div class="last figure align-center" id="id32">
<span id="fig-iar-workspace-pane"></span><a class="reference internal image-reference" href="../_images/image20.jpeg"><img alt="../_images/image20.jpeg" src="../_images/image20.jpeg" style="width: 75%;" /></a>
<p class="caption"><span class="caption-number">Figure 15. </span><span class="caption-text">IAR Workspace Pane</span></p>
</div>
</div>
<p>This workspace file is for the simple_peripheral project. When selected, the
files associated with the workspace become visible in the Workspace pane on the
left side of the screen. See <a class="reference internal" href="#fig-iar-workspace-pane"><span class="std std-numref">Figure 15.</span></a></p>
<p>Select either project as the active project by clicking the respective tab at
the bottom of the workspace pane. In <a class="reference internal" href="#fig-iar-workspace-pane"><span class="std std-numref">Figure 15.</span></a>, the
Overview tab is selected. This tab displays the file structure for both projects
simultaneously. In this case, use the drop-down menu at the top of the workspace
pane to select the active project. Each of these projects produces a separate
downloadable object. The simple_peripheral sample project is the primary
reference target for the description of a generic application in this guide. The
simple_peripheral project implements a basic BLE-Stack peripheral device
including a GATT server with GATT services. This project can be a framework for
developing peripheral-role applications.</p>
</div>
<div class="section" id="blestack-iar-project-build-configurations">
<h3>BLE-Stack 3.00.01 IAR project build configurations<a class="headerlink" href="#blestack-iar-project-build-configurations" title="Permalink to this headline">¶</a></h3>
<p>This and all BLE-Stack 3.00.01 project workspaces contain various projects and build
configurations as shown in <a class="reference internal" href="#tbl-inc-developing-in-iar-build-configs"><span class="std std-numref">Table 7.</span></a>
*_StackLibrary build configurations build the stack as a library as
described in <a class="reference internal" href="#sec-inc-architecture-stack-image-as-a-library"><span class="std std-ref">Stack Library Configuration (_stack_library)</span></a>.</p>
<table border="1" class="docutils" id="id33">
<span id="tbl-inc-developing-in-iar-build-configs"></span><caption><span class="caption-number">Table 7. </span><span class="caption-text">Available IAR project build configurations</span><a class="headerlink" href="#id33" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="18%" />
<col width="41%" />
<col width="42%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Project type</th>
<th class="head">Project&#8217;s build configuration</th>
<th class="head">Compatible project complement</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td rowspan="5">Application</td>
<td>FlashROM</td>
<td>Stack - FlashROM</td>
</tr>
<tr class="row-odd"><td>FlashROM_StackLibrary</td>
<td>Stack - FlashROM_StackLibrary</td>
</tr>
<tr class="row-even"><td>FlashROM_StackLibrary_RCOSC</td>
<td>Stack - FlashROM_StackLibrary</td>
</tr>
<tr class="row-odd"><td>FlashROM_OAD_ImgB</td>
<td>Stack - FlashROM</td>
</tr>
<tr class="row-even"><td>FlashROM_OAD_Offchip</td>
<td>Stack - FlashROM</td>
</tr>
<tr class="row-odd"><td rowspan="2">Stack</td>
<td>FlashROM_Library</td>
<td>Application - FlashROM_Library</td>
</tr>
<tr class="row-even"><td>FlashROM</td>
<td>Application - FlashROM</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="compile-and-download">
<h3>Compile and Download<a class="headerlink" href="#compile-and-download" title="Permalink to this headline">¶</a></h3>
<p>For all build configurations, the stack project should always be built before
the application project.</p>
<p>For projects where the stack is built as a <strong>library</strong>:</p>
<blockquote>
<div><ol class="arabic">
<li><p class="first">Build the stack library project.</p>
<blockquote>
<div><ul class="simple">
<li>Select the stack project.</li>
<li>Select <strong>Project</strong> -&gt; <strong>Make</strong> to build the stack.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">Build the application project.</p>
<blockquote>
<div><ul class="simple">
<li>Select the application project.</li>
<li>Select <strong>Project</strong> -&gt; Make to build the application.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">Load the whole application</p>
<blockquote>
<div><ul class="simple">
<li>To download and debug: Select <strong>Project</strong> -&gt; <strong>Download and Debug</strong></li>
<li>To download without debugging: Select <strong>Project</strong> -&gt; <strong>Download</strong> -&gt;
<strong>Download Active Application</strong></li>
</ul>
</div></blockquote>
</li>
</ol>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Application project that consume the stack in a library form will not
have hard defined image boundaries.</p>
<p class="last">After the initial build, if the stack project is not modified, only the
application project needs to be rebuilt.</p>
</div>
</div></blockquote>
<p>For projects where the stack and application are <strong>split images</strong> (not a library):</p>
<blockquote>
<div><ol class="arabic">
<li><p class="first">Build the stack project.</p>
<blockquote>
<div><ul class="simple">
<li>Select the stack project.</li>
<li>Select <strong>Project</strong> -&gt; <strong>Make</strong> to build the stack.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">Build the application project.</p>
<blockquote>
<div><ul class="simple">
<li>Select the application project.</li>
<li>Select <strong>Project</strong> -&gt; Make to build the application.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">Load the stack project.</p>
<blockquote>
<div><ul class="simple">
<li>Select <strong>Project</strong> -&gt; <strong>Download</strong> -&gt; <strong>Download Active Application</strong>
to download the stack project.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">Load the application project.</p>
<blockquote>
<div><ul class="simple">
<li>To download and debug: Select <strong>Project</strong> -&gt; <strong>Download and Debug</strong></li>
<li>To download without debugging: Select <strong>Project</strong> -&gt; <strong>Download</strong> -&gt;
<strong>Download Active Application</strong></li>
</ul>
</div></blockquote>
</li>
</ol>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The stack project defines the flash and RAM boundary parameters used by
the application project. Any modifications to the stack project require
a rebuild of the stack project, followed by a rebuild of the application
project to use the new boundary settings. See <a class="reference internal" href="#sec-fontier-tool"><span class="std std-ref">Frontier Tool Operation</span></a>.</p>
<p>After the initial build, if the stack project is not modified, only the
application project needs to be rebuilt.</p>
<p class="last">When the application is downloaded (that is, flash memory programmed),
you can debug without reflashing the device. Go to <strong>Project</strong> -&gt;
<strong>Debug without Downloading</strong>.</p>
</div>
</div></blockquote>
<div class="admonition caution">
<p class="first admonition-title">Caution</p>
<p class="last">Do not modify the CPU Variant in the project settings. All sample projects
are configured with a CPU type, and changing this setting (that is, from
CC2640R2F) may result in build errors.</p>
</div>
<p>Sample applications that implement the Over the Air Download (OAD) firmware
update capability require the Boot Image Manager (BIM) project to be built.
Refer to the <a class="reference internal" href="../oad/oad.html#sec-oad"><span class="std std-ref">Over the Air Download (OAD)</span></a> section for more details.</p>
</div>
<div class="section" id="sec-developing-with-iar-accessing-preprocessor-symbols">
<span id="id2"></span><h3>Accessing Preprocessor Symbols<a class="headerlink" href="#sec-developing-with-iar-accessing-preprocessor-symbols" title="Permalink to this headline">¶</a></h3>
<p>Various C preprocessor symbols may need to be set or adjusted at the project
level. The following procedure describes how to access and modify preprocessor
symbols.</p>
<ol class="arabic simple">
<li>Open the Project&#8217;s <strong>Options</strong> and select the <strong>C/C++ Compiler</strong> Category.</li>
<li>Open the <strong>Preprocessor</strong> tab.</li>
<li>View the <strong>Defined symbols</strong> box (see <a class="reference internal" href="#fig-iar-defines-box"><span class="std std-numref">Figure 16.</span></a>).</li>
<li>Add or edit the preprocessor symbols.</li>
</ol>
<div class="figure align-center" id="id34">
<span id="fig-iar-defines-box"></span><img alt="../_images/image38.jpeg" src="../_images/image38.jpeg" />
<p class="caption"><span class="caption-number">Figure 16. </span><span class="caption-text">IAR Defined Symbols Box</span></p>
</div>
</div>
<div class="section" id="sec-developing-with-iar-accessing-linker-symbols">
<span id="id3"></span><h3>Accessing Linker Symbols<a class="headerlink" href="#sec-developing-with-iar-accessing-linker-symbols" title="Permalink to this headline">¶</a></h3>
<p>Linker symbols may need to be set or adjusted at the project level in order to
control the memory layout of the generated image.
The following procedure describes how to access and modify linker
symbols.</p>
<ol class="arabic simple">
<li>Open the Project&#8217;s <strong>Options</strong> and select the <strong>Linker</strong> Category.</li>
<li>Open the <strong>Config</strong> tab.</li>
<li>View the <strong>Configuration File symbol definitions</strong> box (see <a class="reference internal" href="#fig-iar-linker-defines-box"><span class="std std-numref">Figure 17.</span></a>).</li>
<li>Add or edit the preprocessor symbols.</li>
</ol>
<div class="figure align-center" id="id35">
<span id="fig-iar-linker-defines-box"></span><img alt="../_images/iar_linker_opts.png" src="../_images/iar_linker_opts.png" />
<p class="caption"><span class="caption-number">Figure 17. </span><span class="caption-text">IAR Defined Symbols Box</span></p>
</div>
</div>
<div class="section" id="resetting-the-device-in-iar">
<h3>Resetting the CC2640R2F in IAR<a class="headerlink" href="#resetting-the-device-in-iar" title="Permalink to this headline">¶</a></h3>
<p>Select the <em>Board Reset</em> option from the following Reset (back arrow) Debug Menu
drop-down box.</p>
<div class="figure align-center" id="id36">
<a class="reference internal image-reference" href="../_images/image182.jpeg"><img alt="../_images/image182.jpeg" src="../_images/image182.jpeg" style="width: 300px;" /></a>
<p class="caption"><span class="caption-number">Figure 18. </span><span class="caption-text">IAR Board Reset</span></p>
</div>
</div>
</div>
<div class="section" id="ti-rtos-overview">
<span id="sec-tirtos-overview"></span><h2>TI-RTOS Overview<a class="headerlink" href="#ti-rtos-overview" title="Permalink to this headline">¶</a></h2>
<p>TI-RTOS is the operating environment for Bluetooth low energy projects on
CC2640R2F devices. The TI-RTOS kernel is a tailored version of the legacy
SYS/BIOS kernel and operates as a real-time, preemptive, multi-threaded
operating system with drivers, tools for synchronization and scheduling.</p>
<div class="section" id="threading-modules">
<h3>Threading Modules<a class="headerlink" href="#threading-modules" title="Permalink to this headline">¶</a></h3>
<p>The TI-RTOS kernel manages four distinct context levels of thread execution as
shown in <a class="reference internal" href="#tirtos-threads"><span class="std std-numref">Figure 19.</span></a> The list of thread modules are shown below in
a descending order in terms of priority.</p>
<blockquote>
<div><ul class="simple">
<li>A <a class="reference internal" href="glossary.html#term-hwi"><span class="xref std std-term">Hwi</span></a> or Hardware interrupt.</li>
<li>A <a class="reference internal" href="glossary.html#term-swi"><span class="xref std std-term">Swi</span></a> or Software interrupt.</li>
<li>Tasks</li>
<li>The <a class="reference internal" href="glossary.html#term-idle-task"><span class="xref std std-term">Idle Task</span></a> for background idle functions.</li>
</ul>
</div></blockquote>
<div class="figure align-center" id="id37">
<span id="tirtos-threads"></span><img alt="../_images/image45.jpeg" src="../_images/image45.jpeg" />
<p class="caption"><span class="caption-number">Figure 19. </span><span class="caption-text">TI-RTOS Execution Threads</span></p>
</div>
<p>This section describes these four execution threads and various structures used
throughout the TI-RTOS for messaging and synchronization. In most cases, the
underlying TI-RTOS functions have been abstracted to higher-level functions in
util.c (<a class="reference external" href="../../doxygen/group___util.html">Util</a>). The lower-level TI-RTOS functions are described in the
TI-RTOS Kernel API Guide found here <a class="reference external" href="../../../../tirtos/sysbios/docs/Bios_User_Guide.pdf">TI-RTOS Kernel User Guide</a>. This document
also defines the packages and modules included with the TI-RTOS.</p>
<div class="section" id="hardware-interrupts-hwi">
<h4>Hardware Interrupts (Hwi)<a class="headerlink" href="#hardware-interrupts-hwi" title="Permalink to this headline">¶</a></h4>
<p>Hwi threads (also called Interrupt Service Routines or ISRs) are the threads
with the highest priority in a TI-RTOS application. Hwi threads are used to
perform time critical tasks that are subject to hard deadlines. They are
triggered in response to external asynchronous events (interrupts) that occur in
the real-time environment. Hwi threads always run to completion but can be
preempted temporarily by Hwi threads triggered by other interrupts, if enabled.
Specific information on the nesting, vectoring, and functionality of interrupts
can be found in the <a class="reference external" href="http://www.ti.com/lit/pdf/swcu117">CC26xx Technical Reference Manual</a>.</p>
<p>Generally, interrupt service routines are kept short as not to affect the
hard real-time system requirements. Also, as Hwis must run to completion, no
blocking APIs may be called from within this context.</p>
<p>TI-RTOS drivers that require interrupts will initialize the required interrupts
for the assigned peripheral. See <a class="reference internal" href="#tirtos-drivers"><span class="std std-ref">Drivers</span></a> for more information.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><a class="reference internal" href="../debugging/ble-debugging.html#sec-debugging"><span class="std std-ref">Debugging</span></a> provides an example of using GPIOs and Hwis.
While the SDK includes a peripheral driver library to abstract hardware
register access, it is suggested to use the thread-safe TI-RTOS drivers as
described in <a class="reference internal" href="#tirtos-drivers"><span class="std std-ref">Drivers</span></a>.</p>
</div>
<p>The Hwi module for the CC2640R2F also supports <a class="reference internal" href="glossary.html#term-zero-latency-interrupts"><span class="xref std std-term">Zero-latency interrupts</span></a>.
These interrupts do not go through the TI-RTOS Hwi dispatcher and therefore are
more responsive than standard interrupts, however this feature prohibits its
interrupt service routine from invoking any TI-RTOS kernel APIs directly. It
is up to the ISR to preserve its own context to prevent it from interfering with
the kernel&#8217;s scheduler.</p>
<p>For the Bluetooth low energy protocol stack to meet RF time-critical
requirements, all application-defined Hwis execute at the lowest priority.
TI does not recommend modifying the default Hwi priority when adding new
Hwis to the system. No application-defined critical sections should exist to
prevent breaking TI-RTOS or time-critical sections of the Bluetooth low
energy protocol stack. Code executing in a critical section prevents
processing of real-time interrupt-related events.</p>
</div>
<div class="section" id="software-interrupts-swi">
<h4>Software Interrupts (Swi)<a class="headerlink" href="#software-interrupts-swi" title="Permalink to this headline">¶</a></h4>
<p>Patterned after hardware interrupts (<a class="reference internal" href="glossary.html#term-hwi"><span class="xref std std-term">Hwi</span></a>), software interrupt threads
provide additional priority levels between Hwi threads and Task threads. Unlike
Hwis, which are triggered by hardware interrupts, Swis are triggered
programmatically by calling certain Swi module APIs. Swis handle threads subject
to time constraints that preclude them from being run as tasks, but whose
deadlines are not as severe as those of hardware ISRs. Like Hwis, Swi threads
always run to completion. Swis allow Hwis to defer less critical processing to a
lower-priority thread, minimizing the time the CPU spends inside an interrupt
service routine, where other Hwis can be disabled. Swis require only enough
space to save the context for each Swi interrupt priority level, while Tasks use
a separate stack for each thread.</p>
<p>Similar with Hwis, Swis should be kept to short and may not include any blocking
API calls. This allows high priority tasks such as the wireless protocol
stack to execute as needed. It is suggested to <code class="docutils literal"><span class="pre">_post()</span></code> some TI-RTOS
synchronization primitive to allow for further post processing from within a
Task context. See <a class="reference internal" href="#fig-preemption-scenario"><span class="std std-numref">Figure 20.</span></a> to illustrate such a
use-case.</p>
<div class="figure align-center" id="id38">
<span id="fig-preemption-scenario"></span><img alt="../_images/image56.jpeg" src="../_images/image56.jpeg" />
<p class="caption"><span class="caption-number">Figure 20. </span><span class="caption-text">Preemption Scenario</span></p>
</div>
<p>The commonly used Clock module operates from within a Swi context. It is
important that functions called by a Clock object do not invoke blocking APIs
and are rather short in execution.</p>
</div>
<div class="section" id="task">
<h4>Task<a class="headerlink" href="#task" title="Permalink to this headline">¶</a></h4>
<p>Task threads have higher priority than the background (Idle) thread and lower
priority than software interrupts. Tasks differ from software interrupts in that
they can wait (block) during execution until necessary resources are available.
Tasks require a separate stack for each thread. TI-RTOS provides a number of
mechanisms that can be used for inter-task communication and synchronization.
These include Semaphores, Event, Message queues, and Mailboxes.</p>
<p>See <a class="reference internal" href="#sec-rtos-overview-tasks"><span class="std std-ref">Tasks</span></a> for more details.</p>
</div>
<div class="section" id="idle-task">
<h4>Idle Task<a class="headerlink" href="#idle-task" title="Permalink to this headline">¶</a></h4>
<p>Idle threads execute at the lowest priority in a TI-RTOS application and are
executed one after another in a continuous loop (the Idle Loop). After main
returns, a TI-RTOS application calls the startup routine for each TI-RTOS module
and then falls into the Idle Loop. Each thread must wait for all others to
finish executing before it is called again. The Idle Loop runs continuously
except when it is preempted by higher-priority threads. Only functions that do
not have hard deadlines should be executed in the Idle Loop.</p>
<p>For CC2640R2F devices, the idle task allows the Power Policy Manager to enter
the lowest allowable power savings.</p>
</div>
</div>
<div class="section" id="kernel-configuration">
<h3>Kernel Configuration<a class="headerlink" href="#kernel-configuration" title="Permalink to this headline">¶</a></h3>
<p>A TI-RTOS application configures the TI-RTOS kernel using a configuration
(<code class="docutils literal"><span class="pre">.cfg</span></code> file) that is found within the project. In <a class="reference internal" href="glossary.html#term-iar"><span class="xref std std-term">IAR</span></a> and <a class="reference internal" href="glossary.html#term-ccs"><span class="xref std std-term">CCS</span></a>
projects, this file is found in the application project workspace under the
<code class="docutils literal"><span class="pre">TOOLS</span></code> folder.</p>
<p>The configuration is accomplished by selectively including or <em>using</em>
<a class="reference internal" href="glossary.html#term-rtsc"><span class="xref std std-term">RTSC</span></a> modules available to the kernel. To <em>use</em> a module, the <code class="docutils literal"><span class="pre">.cfg</span></code>
calls <code class="docutils literal"><span class="pre">xdc.useModule()</span></code> after which it can set various options as defined
in the <a class="reference external" href="../../../../tirtos/sysbios/docs/Bios_User_Guide.pdf">TI-RTOS Kernel User Guide</a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Projects in the BLE-Stack (such as simple_peripheral) typically will
contain an <code class="docutils literal"><span class="pre">app_ble.cfg</span></code> configuration file.</p>
</div>
<p>Some of the option that can be configured in the <code class="docutils literal"><span class="pre">.cfg</span></code> file include but are
not limited to:</p>
<blockquote>
<div><ul class="simple">
<li>Boot options</li>
<li>Number of Hwi, Swi, and Task priorities</li>
<li>Exception and Error handling</li>
<li>The duration of a System tick (the most fundamental <em>unit</em> of time in the
TI-RTOS kernel).</li>
<li>Defining the application&#8217;s entry point and interrupt vector</li>
<li>TI-RTOS heaps and stacks (not to be confused with other heap managers!)</li>
<li>Including pre-compiled kernel and TI-RTOS driver libraries</li>
<li>System provides (for <code class="docutils literal"><span class="pre">System_printf()</span></code>)</li>
</ul>
</div></blockquote>
<p>Whenever a change in the <code class="docutils literal"><span class="pre">.cfg</span></code> file is made, you will rerun the XDCTools&#8217;
<code class="docutils literal"><span class="pre">configuro</span></code> tool. This step is already handled for you as a pre-build step in
the provided <a class="reference internal" href="glossary.html#term-iar"><span class="xref std std-term">IAR</span></a> and <a class="reference internal" href="glossary.html#term-ccs"><span class="xref std std-term">CCS</span></a> examples.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The name of the .cfg doesn&#8217;t really matter. A project should however only
include one <code class="docutils literal"><span class="pre">.cfg</span></code> file.</p>
</div>
<p>For CC26xx and CC13xx devices, a TI-RTOS kernel exists in <a class="reference internal" href="glossary.html#term-rom"><span class="xref std std-term">ROM</span></a>.
Typically for flash footprint savings, the <code class="docutils literal"><span class="pre">.cfg</span></code> will include the kernel&#8217;s
<a class="reference internal" href="glossary.html#term-rom"><span class="xref std std-term">ROM</span></a> module as shown in <a class="reference internal" href="#rom-listing"><span class="std std-numref">Listing 1.</span></a></p>
<div class="literal-block-wrapper docutils container" id="how-to-include-the-ti-rtos-kernel-in-rom">
<span id="rom-listing"></span><div class="code-block-caption"><span class="caption-number">Listing 1. </span><span class="caption-text">How to include the TI-RTOS kernel in ROM</span><a class="headerlink" href="#how-to-include-the-ti-rtos-kernel-in-rom" title="Permalink to this code">¶</a></div>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="cm">/* ================ ROM configuration ================ */</span>
<span class="cm">/*</span>
<span class="cm"> * To use BIOS in flash, comment out the code block below.</span>
<span class="cm"> */</span>
<span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">NO_ROM</span> <span class="o">==</span> <span class="s1">&#39;undefined&#39;</span> <span class="o">||</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">NO_ROM</span> <span class="o">!=</span> <span class="s1">&#39;undefined&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">NO_ROM</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
<span class="p">{</span>
<span class="hll">  <span class="kd">var</span> <span class="nx">ROM</span> <span class="o">=</span> <span class="nx">xdc</span><span class="p">.</span><span class="nx">useModule</span><span class="p">(</span><span class="s1">&#39;ti.sysbios.rom.ROM&#39;</span><span class="p">);</span>
</span>  <span class="k">if</span> <span class="p">(</span><span class="nx">Program</span><span class="p">.</span><span class="nx">cpu</span><span class="p">.</span><span class="nx">deviceName</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="sr">/CC26/</span><span class="p">))</span> <span class="p">{</span>
<span class="hll">      <span class="nx">ROM</span><span class="p">.</span><span class="nx">romName</span> <span class="o">=</span> <span class="nx">ROM</span><span class="p">.</span><span class="nx">CC2640R2F</span><span class="p">;</span>
</span>  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">Program</span><span class="p">.</span><span class="nx">cpu</span><span class="p">.</span><span class="nx">deviceName</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="sr">/CC13/</span><span class="p">))</span> <span class="p">{</span>
<span class="hll">      <span class="nx">ROM</span><span class="p">.</span><span class="nx">romName</span> <span class="o">=</span> <span class="nx">ROM</span><span class="p">.</span><span class="nx">CC1350</span><span class="p">;</span>
</span>  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>The TI-RTOS kernel in <a class="reference internal" href="glossary.html#term-rom"><span class="xref std std-term">ROM</span></a> is optimized for performance. If additional
instrumentation is required in your application (typically for debugging), you
must include the TI-RTOS kernel in flash which will increase flash memory
consumption. Shown below is a short list of requirements to use the TI-RTOS
kernel in <a class="reference internal" href="glossary.html#term-rom"><span class="xref std std-term">ROM</span></a>.</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">BIOS.assertsEnabled</span></code> <strong>must</strong> be set to <code class="docutils literal"><span class="pre">false</span></code></li>
<li><code class="docutils literal"><span class="pre">BIOS.logsEnabled</span></code> <strong>must</strong> be set to <code class="docutils literal"><span class="pre">false</span></code></li>
<li><code class="docutils literal"><span class="pre">BIOS.taskEnabled</span></code> <strong>must</strong> be set to <code class="docutils literal"><span class="pre">true</span></code></li>
<li><code class="docutils literal"><span class="pre">BIOS.swiEnabled</span></code> <strong>must</strong> be set to <code class="docutils literal"><span class="pre">true</span></code></li>
<li><code class="docutils literal"><span class="pre">BIOS.runtimeCreatesEnabled</span></code> <strong>must</strong> be set to <code class="docutils literal"><span class="pre">true</span></code></li>
<li>BIOS <strong>must</strong> use the <code class="docutils literal"><span class="pre">ti.sysbios.gates.GateMutex</span></code> module</li>
<li><code class="docutils literal"><span class="pre">Clock.tickSource</span></code> <strong>must</strong> be set to <code class="docutils literal"><span class="pre">Clock.TickSource_TIMER</span></code></li>
<li><code class="docutils literal"><span class="pre">Semaphore.supportsPriority</span></code> <strong>must</strong> be <code class="docutils literal"><span class="pre">false</span></code></li>
<li>Swi, Task, and Hwi hooks are <strong>not</strong> permitted</li>
<li>Swi, Task, and Hwi name instances are <strong>not</strong> permitted</li>
<li>Task stack checking is <strong>disabled</strong></li>
<li><code class="docutils literal"><span class="pre">Hwi.disablePriority</span></code> <strong>must</strong> be set to <code class="docutils literal"><span class="pre">0x20</span></code></li>
<li><code class="docutils literal"><span class="pre">Hwi.dispatcherAutoNestingSupport</span></code> <strong>must</strong> be set to true</li>
<li>The default Heap instance <strong>must</strong> set to the <code class="docutils literal"><span class="pre">ti.sysbios.heaps.HeapMem</span></code>
manager</li>
</ul>
</div></blockquote>
<p>For additional documentation in regards to the list described above, see the
<a class="reference external" href="../../../../tirtos/sysbios/docs/Bios_User_Guide.pdf">TI-RTOS Kernel User Guide</a>.</p>
</div>
<div class="section" id="creating-vs-constructing">
<span id="create-vs-construct"></span><h3>Creating vs. Constructing<a class="headerlink" href="#creating-vs-constructing" title="Permalink to this headline">¶</a></h3>
<p>Most TI-RTOS modules commonly have <code class="docutils literal"><span class="pre">_create()</span></code> and <code class="docutils literal"><span class="pre">_construct()</span></code> APIs to
initialize primitive instances. The main <strong>runtime</strong> differences between the two
APIs are memory allocation and error handling.</p>
<p><strong>Create</strong> APIs perform a memory allocation from the default TI-RTOS heap before
initialization. As a result, the application <em>must</em> check the return value for a
valid handle before continuing.</p>
<div class="literal-block-wrapper docutils container" id="creating-a-semaphore">
<span id="create-example-listing"></span><div class="code-block-caption"><span class="caption-number">Listing 2. </span><span class="caption-text">Creating a Semaphore</span><a class="headerlink" href="#creating-a-semaphore" title="Permalink to this code">¶</a></div>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">Semaphore_Handle</span> <span class="n">sem</span><span class="p">;</span>
<span class="n">Semaphore_Params</span> <span class="n">semParams</span><span class="p">;</span>

<span class="n">Semaphore_Params_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">semParams</span><span class="p">);</span>
<span class="hll"><span class="n">sem</span> <span class="o">=</span> <span class="n">Semaphore_create</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">semParams</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span> <span class="cm">/* Memory allocated in here */</span>
</span>
<span class="hll"><span class="k">if</span> <span class="p">(</span><span class="n">sem</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="cm">/* Check if the handle is valid */</span>
</span><span class="p">{</span>
  <span class="n">System_abort</span><span class="p">(</span><span class="s">&quot;Semaphore could not be created&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</div>
<p><strong>Construct</strong> APIs are given a data structure with which to store the instance&#8217;s
variables. As the memory has been pre-allocated for the instance, error checking
may not be required after constructing.</p>
<div class="literal-block-wrapper docutils container" id="constructing-a-semaphore">
<span id="construct-example-listing"></span><div class="code-block-caption"><span class="caption-number">Listing 3. </span><span class="caption-text">Constructing a Semaphore</span><a class="headerlink" href="#constructing-a-semaphore" title="Permalink to this code">¶</a></div>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">Semaphore_Handle</span> <span class="n">sem</span><span class="p">;</span>
<span class="n">Semaphore_Params</span> <span class="n">semParams</span><span class="p">;</span>
<span class="hll"><span class="n">Semaphore_Struct</span> <span class="n">structSem</span><span class="p">;</span> <span class="cm">/* Memory allocated at build time */</span>
</span>
<span class="n">Semaphore_Params_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">semParams</span><span class="p">);</span>
<span class="hll"><span class="n">Semaphore_construct</span><span class="p">(</span><span class="o">&amp;</span><span class="n">structSem</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">semParams</span><span class="p">);</span>
</span>
<span class="cm">/* It&#39;s optional to store the handle */</span>
<span class="n">sem</span> <span class="o">=</span> <span class="n">Semaphore_handle</span><span class="p">(</span><span class="o">&amp;</span><span class="n">structSem</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
</div>
</div>
<div class="section" id="thread-synchronization">
<h3>Thread Synchronization<a class="headerlink" href="#thread-synchronization" title="Permalink to this headline">¶</a></h3>
<p>The TI-RTOS kernel provides several modules for synchronizing tasks such as
Semaphore, Event, and Queue. The following sections discuss these common
TI-RTOS primitives.</p>
<div class="section" id="semaphores">
<h4>Semaphores<a class="headerlink" href="#semaphores" title="Permalink to this headline">¶</a></h4>
<p>Semaphores are commonly used for task synchronization and mutual exclusions
throughout TI-RTOS applications. <a class="reference internal" href="#fig-semaphore"><span class="std std-numref">Figure 21.</span></a> shows the semaphore
functionality. Semaphores can be counting semaphores or binary semaphores.
Counting semaphores keep track of the number of times the semaphore is posted
with <code class="docutils literal"><span class="pre">Semaphore_post()</span></code>. When a group of resources are shared between tasks,
this function is useful. Such tasks might call <code class="docutils literal"><span class="pre">Semaphore_pend()</span></code> to see if a
resource is available before using one. Binary semaphores can have only two
states: available (count = 1) and unavailable (count = 0). Binary semaphores
can be used to share a single resource between tasks or for a basic-signaling
mechanism where the semaphore can be posted multiple times. Binary semaphores do
not keep track of the count; they track only whether the semaphore has been
posted.</p>
<div class="figure align-center" id="id39">
<span id="fig-semaphore"></span><img alt="../_images/image47.jpeg" src="../_images/image47.jpeg" />
<p class="caption"><span class="caption-number">Figure 21. </span><span class="caption-text">Semaphore Functionality</span></p>
</div>
<div class="section" id="initializing-a-semaphore">
<h5>Initializing a Semaphore<a class="headerlink" href="#initializing-a-semaphore" title="Permalink to this headline">¶</a></h5>
<p>The following code depicts how a semaphore is initialized in TI-RTOS. Semaphores
can be <em>created</em> and <em>constructed</em> as explained in <a class="reference internal" href="#create-vs-construct"><span class="std std-ref">Creating vs. Constructing</span></a>.</p>
<p>See <a class="reference internal" href="#create-example-listing"><span class="std std-numref">Listing 2.</span></a> on how to create a Semaphore.</p>
<p>See <a class="reference internal" href="#construct-example-listing"><span class="std std-numref">Listing 3.</span></a> on how to construct a Semaphore.</p>
</div>
<div class="section" id="pending-on-a-semaphore">
<h5>Pending on a Semaphore<a class="headerlink" href="#pending-on-a-semaphore" title="Permalink to this headline">¶</a></h5>
<p><code class="docutils literal"><span class="pre">Semaphore_pend()</span></code> is a blocking function call. This call may only be called
from within a Task context. A task calling this function will allow lower
priority tasks to execute, if they are ready to run. A task calling
<code class="docutils literal"><span class="pre">Semaphore_pend()</span></code> will block if its counter is 0, otherwise it will decrement
the counter by one. The task will remain blocked until another thread calls
<code class="docutils literal"><span class="pre">Semaphore_post()</span></code> or if the supplied system tick timeout has occurred;
whichever comes first. By reading the return value of <code class="docutils literal"><span class="pre">Semaphore_pend()</span></code> it is
possible to distinguish if a semaphore was posted or if it timed out.</p>
<div class="literal-block-wrapper docutils container" id="id4">
<span id="pending-semaphore-listing"></span><div class="code-block-caption"><span class="caption-number">Listing 4. </span><span class="caption-text">Pending on a Semaphore</span><a class="headerlink" href="#id4" title="Permalink to this code">¶</a></div>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="n">isSuccessful</span><span class="p">;</span>
<span class="kt">uint32_t</span> <span class="n">timeout</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1000</span><span class="o">/</span><span class="n">Clock_tickPeriod</span><span class="p">);</span>

<span class="cm">/* Pend (approximately) up to 1 second */</span>
<span class="hll"><span class="n">isSuccessful</span> <span class="o">=</span> <span class="n">Semaphore_pend</span><span class="p">(</span><span class="n">sem</span><span class="p">,</span> <span class="n">timeoutInTicks</span><span class="p">);</span>
</span>
<span class="k">if</span> <span class="p">(</span><span class="n">isSuccessful</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">System_printf</span><span class="p">(</span><span class="s">&quot;Semaphore was posted&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
    <span class="n">System_printf</span><span class="p">(</span><span class="s">&quot;Semaphore timed out&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The default TI-RTOS system tick period is 1 millisecond. This default is
reconfigured to 10 microseconds for CC26xx and CC13xx devices by setting
<code class="docutils literal"><span class="pre">Clock.tickPeriod</span> <span class="pre">=</span> <span class="pre">10</span></code> in the <code class="docutils literal"><span class="pre">.cfg</span></code> file.</p>
<p class="last">Given a system tick of 10 microseconds, <code class="docutils literal"><span class="pre">timeout</span></code> in
<a class="reference internal" href="#pending-semaphore-listing"><span class="std std-numref">Listing 4.</span></a> will be approximately 1 second.</p>
</div>
</div>
<div class="section" id="posting-a-semaphore">
<h5>Posting a Semaphore<a class="headerlink" href="#posting-a-semaphore" title="Permalink to this headline">¶</a></h5>
<p>Posting a semaphore is accomplished via a call to <code class="docutils literal"><span class="pre">Semaphore_post()</span></code>. A task
that is pending on a posted semaphore will transition from a <em>blocked</em> state to
a <em>ready</em> state. If no higher priority thread is <em>ready</em> to run, it will allow
the previously pending task to execute. If no task is pending on the semaphore,
a call to <code class="docutils literal"><span class="pre">Semaphore_post()</span></code> will increment its counter. Binary semaphores
have a maximum count of 1.</p>
<div class="literal-block-wrapper docutils container" id="id5">
<span id="posting-semaphore-listing"></span><div class="code-block-caption"><span class="caption-number">Listing 5. </span><span class="caption-text">Posting a Semaphore</span><a class="headerlink" href="#id5" title="Permalink to this code">¶</a></div>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="hll"><span class="n">Semaphore_post</span><span class="p">(</span><span class="n">sem</span><span class="p">);</span>
</span></pre></div>
</td></tr></table></div>
</div>
</div>
</div>
<div class="section" id="event">
<span id="sec-rtos-overview-event"></span><h4>Event<a class="headerlink" href="#event" title="Permalink to this headline">¶</a></h4>
<p>Semaphores themselves provide rudimentary synchronization between threads. There
are cases just the Semaphore itself is enough to understand on what process
needs to be triggered. Often however, a specific causes for the synchronization
need to be passed across threads as well. To help accomplish this, one can
utilize the TI-RTOS <strong>Event</strong> module.
Events are similar to Semaphores in a sense that each instance of an event
object actually contains a Semaphore. The added advantage of using Events lie in
the fact that tasks can be notified of specific events in a thread-safe manner.</p>
<div class="section" id="initializing-an-event">
<h5>Initializing an Event<a class="headerlink" href="#initializing-an-event" title="Permalink to this headline">¶</a></h5>
<p><em>Creating</em> and <em>constructing</em> events follow the same guidelines as explained in
<a class="reference internal" href="#create-vs-construct"><span class="std std-ref">Creating vs. Constructing</span></a>. Shown in <a class="reference internal" href="#event-initialize-listing"><span class="std std-numref">Listing 6.</span></a> is an
example on how to <em>construct</em> an Event instance.</p>
<div class="literal-block-wrapper docutils container" id="constructing-an-event">
<span id="event-initialize-listing"></span><div class="code-block-caption"><span class="caption-number">Listing 6. </span><span class="caption-text">Constructing an Event</span><a class="headerlink" href="#constructing-an-event" title="Permalink to this code">¶</a></div>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">Event_Handle</span> <span class="n">event</span><span class="p">;</span>
<span class="n">Event_Params</span> <span class="n">eventParams</span><span class="p">;</span>
<span class="n">Event_Struct</span> <span class="n">structEvent</span><span class="p">;</span> <span class="cm">/* Memory allocated at build time */</span>

<span class="n">Event_Params_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">eventParams</span><span class="p">);</span>
<span class="hll"><span class="n">Event_construct</span><span class="p">(</span><span class="o">&amp;</span><span class="n">structEvent</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eventParams</span><span class="p">);</span>
</span>
<span class="cm">/* It&#39;s optional to store the handle */</span>
<span class="n">event</span> <span class="o">=</span> <span class="n">Event_handle</span><span class="p">(</span><span class="o">&amp;</span><span class="n">structEvent</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
</div>
</div>
<div class="section" id="pending-on-an-event">
<h5>Pending on an Event<a class="headerlink" href="#pending-on-an-event" title="Permalink to this headline">¶</a></h5>
<p>Similar to <code class="docutils literal"><span class="pre">Semaphore_pend()</span></code>, a task thread would typically block on an
<code class="docutils literal"><span class="pre">Event_pend()</span></code> until an event is posted via an <code class="docutils literal"><span class="pre">Event_post()</span></code> or if the
specified timeout expired. Shown in <a class="reference internal" href="#pending-event-listing"><span class="std std-numref">Listing 7.</span></a> is a snippet
of a task pending on <em>any</em> of the 3 sample event IDs shown below.
<code class="docutils literal"><span class="pre">BIOS_WAIT_FOREVER</span></code> is used to prevent a timeout from occurring. As a result,
<code class="docutils literal"><span class="pre">Event_pend()</span></code> will have one or more events posted in the returned bit-masked
value.</p>
<p>Each event returned from <code class="docutils literal"><span class="pre">Event_pend()</span></code> has been automatically cleared within
the event instance in a thread-safe manner. Therefore, it is only necessary to
keep a local copy of posted events. For full details on how to use
<code class="docutils literal"><span class="pre">Event_pend()</span></code>, see the <a class="reference external" href="../../../../tirtos/sysbios/docs/Bios_User_Guide.pdf">TI-RTOS Kernel User Guide</a>.</p>
<div class="literal-block-wrapper docutils container" id="id6">
<span id="pending-event-listing"></span><div class="code-block-caption"><span class="caption-number">Listing 7. </span><span class="caption-text">Pending on an Event</span><a class="headerlink" href="#id6" title="Permalink to this code">¶</a></div>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#define START_ADVERTISING_EVT         Event_Id_00</span>
<span class="cp">#define START_CONN_UPDATE_EVT         Event_Id_01</span>
<span class="cp">#define CONN_PARAM_TIMEOUT_EVT        Event_Id_02</span>

<span class="kt">void</span> <span class="nf">TaskFxn</span><span class="p">(..)</span>
<span class="p">{</span>
    <span class="cm">/* Local copy of events that have been posted */</span>
<span class="hll">    <span class="kt">uint32_t</span> <span class="n">events</span><span class="p">;</span>
</span>
    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="cm">/* Wait for an event to be posted */</span>
<span class="hll">        <span class="n">events</span> <span class="o">=</span> <span class="n">Event_pend</span><span class="p">(</span><span class="n">event</span><span class="p">,</span>
</span><span class="hll">                            <span class="n">Event_Id_NONE</span><span class="p">,</span>
</span><span class="hll">                            <span class="n">START_ADVERTISING_EVT</span> <span class="o">|</span>
</span><span class="hll">                            <span class="n">START_CONN_UPDATE_EVT</span> <span class="o">|</span>
</span><span class="hll">                            <span class="n">CONN_PARAM_TIMEOUT_EVT</span><span class="p">,</span>
</span><span class="hll">                            <span class="n">BIOS_WAIT_FOREVER</span><span class="p">);</span>
</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">START_ADVERTISING_EVT</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="cm">/* Process this event */</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">START_CONN_UPDATE_EVT</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="cm">/* Process this event */</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">CONN_PARAM_TIMEOUT_EVT</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="cm">/* Process this event */</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The default TI-RTOS system tick period is 1 millisecond. This default is
reconfigured to 10 microseconds for CC26xx and CC13xx devices by setting
<code class="docutils literal"><span class="pre">Clock.tickPeriod</span> <span class="pre">=</span> <span class="pre">10</span></code> in the <code class="docutils literal"><span class="pre">.cfg</span></code> file.</p>
<p class="last">Given a system tick of 10 microseconds, <code class="docutils literal"><span class="pre">timeout</span></code> in
<a class="reference internal" href="#pending-semaphore-listing"><span class="std std-numref">Listing 4.</span></a> will be approximately 1 second.</p>
</div>
</div>
<div class="section" id="posting-an-event">
<h5>Posting an Event<a class="headerlink" href="#posting-an-event" title="Permalink to this headline">¶</a></h5>
<p>Events may be posted from any TI-RTOS kernel contexts and is simply done by
calling <code class="docutils literal"><span class="pre">Event_post()</span></code> of the event instance and the event ID.
<a class="reference internal" href="#posting-event-listing"><span class="std std-numref">Listing 8.</span></a> shows how a high priority thread such as a Swi
could post a specific event.</p>
<div class="literal-block-wrapper docutils container" id="id7">
<span id="posting-event-listing"></span><div class="code-block-caption"><span class="caption-number">Listing 8. </span><span class="caption-text">Posting an Event</span><a class="headerlink" href="#id7" title="Permalink to this code">¶</a></div>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#define START_ADVERTISING_EVT         Event_Id_00</span>
<span class="cp">#define START_CONN_UPDATE_EVT         Event_Id_01</span>
<span class="cp">#define CONN_PARAM_TIMEOUT_EVT        Event_Id_02</span>

<span class="kt">void</span> <span class="nf">SwiFxn</span><span class="p">(</span><span class="n">UArg</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
<span class="hll">    <span class="n">Event_post</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">START_ADVERTISING_EVT</span><span class="p">);</span>
</span><span class="p">}</span>
</pre></div>
</td></tr></table></div>
</div>
</div>
</div>
<div class="section" id="queues">
<h4>Queues<a class="headerlink" href="#queues" title="Permalink to this headline">¶</a></h4>
<p>Queues let applications process messages in a first in, first out (FIFO) order.
A project may use a queue to manage internal events coming from application
profiles or another task.
Clocks must be used when an event must be processed in a time-critical manner.
Queues are more useful for message passing across various thread contexts.</p>
<p>The Queue module provides a unidirectional method of message passing
between threads using a FIFO. In <a class="reference internal" href="#fig-queue-messaging-process"><span class="std std-numref">Figure 22.</span></a> a queue
is configured for unidirectional communication from task A to task B. Task A
pushes messages into the queue and task B pops messages from the queue in order.
<a class="reference internal" href="#fig-queue-messaging-process"><span class="std std-numref">Figure 22.</span></a> shows the queue messaging process.</p>
<div class="figure align-center" id="id40">
<span id="fig-queue-messaging-process"></span><img alt="../_images/image51.jpeg" src="../_images/image51.jpeg" />
<p class="caption"><span class="caption-number">Figure 22. </span><span class="caption-text">Queue Messaging Process</span></p>
</div>
<p>The TI-RTOS Queue functions have been abstracted into functions in the <code class="docutils literal"><span class="pre">util.c</span></code>
file. See the Queue module in the <a class="reference external" href="../../../../tirtos/sysbios/docs/Bios_User_Guide.pdf">TI-RTOS Kernel User Guide</a> for the
underlying functions. These utility functions combine the Queue module with the
ability to notify the recipient task of an available message through TI-RTOS Event
Module.</p>
<p>In CC2640R2F software, the event used for this process is the same event that the
given task uses for task synchronization through ICall. For an example of this,
see the <code class="docutils literal"><span class="pre">SimpleBLECentral_enqueueMsg()</span></code> function. Queues are commonly used to
limit the processing time of application callbacks in the context of the higher
priority threads. In this manner, the higher priority thread queues a message to
the application to process later instead of immediate processing in its own
context.</p>
<p>The <code class="docutils literal"><span class="pre">Util</span></code> module contains a set of abstracted TI-RTOS Queue functions as
shown here:</p>
<ul class="simple">
<li><a class="reference external" href="../../doxygen/group___util.html#ga1a402aa73798e67c21ea960bb67ed516">Util_constructQueue()</a> creates a queue.</li>
<li><a class="reference external" href="../../doxygen/group___util.html#gada1270148b25421486d6a0f6e001a3b5">Util_enqueueMsg()</a> puts items into the queue.</li>
<li><a class="reference external" href="../../doxygen/group___util.html#ga2119072ce502da984eed8a9dd614da07">Util_dequeueMsg()</a> gets items from the queue.</li>
</ul>
<div class="section" id="functional-example">
<h5>Functional Example<a class="headerlink" href="#functional-example" title="Permalink to this headline">¶</a></h5>
<p><a class="reference internal" href="#fig-enqueue-message"><span class="std std-numref">Figure 23.</span></a> and <a class="reference internal" href="#fig-dequeue-message"><span class="std std-numref">Figure 24.</span></a> illustrate
how a queue can be used to enqueue a button press from Hwi (to Swi in the Board
Key module) to be processed within a Task when no other high priority events are
occurring. The example was taken from the from the simple_central project in
BLE-Stack 3.00.01.</p>
<div class="figure align-center" id="id41">
<span id="fig-enqueue-message"></span><p class="plantuml">
<img src="../_images/plantuml-0c947cf0f66a5ea55c69bfe1e2f3068eabcbe756.png" alt="&#64;startuml
hide footbox

box &quot;Swi context&quot;
    participant &quot;Board Key module&quot; as A
    participant simple_central.c as B
    database appMsgQueue as C
end box

-[#red]&gt; A : Key press interrupt
&lt;[#red]-- A

activate A

autonumber
A -&gt; B : SimpleBLECentral_keyChangeHandler();
activate B

note right: Add SBC_KEY_CHANGE_EVT into the queue
B -&gt; B : SimpleBLECentral_enqueueMsg();
activate B
autonumber stop
B -&gt; : ICall_malloc();
B -&gt; C: Util_enqueueMsg();
activate C
C --&gt; B:
deactivate C
B -&gt; : Event_post();
deactivate B
B --&gt; A
deactivate B
deactivate A

&#64;enduml" />
</p>
<p class="caption"><span class="caption-number">Figure 23. </span><span class="caption-text">Sequence diagram for enqueuing a message</span><a class="headerlink" href="#id41" title="Permalink to this image">¶</a></p>
</div>
<p>With interrupts enabled, a pin interrupt can occur asynchronously within a
<a class="reference internal" href="glossary.html#term-hwi"><span class="xref std std-term">Hwi</span></a> context. To keep interrupts as short as possible, the work
associated with the interrupt is deferred to lower priority contexts for
processing. In the simple_central example found in BLE-Stack 3.00.01, pin
interrupts are abstracted via a <em>Board Key module</em>. This module will notify
registered functions via a callback from within a <a class="reference internal" href="glossary.html#term-swi"><span class="xref std std-term">Swi</span></a> context. In this
case, <code class="docutils literal"><span class="pre">SimpleBLECentral_keyChangeHandler</span></code> is the registered callback function.</p>
<p><strong>Step 1</strong> in <a class="reference internal" href="#fig-enqueue-message"><span class="std std-numref">Figure 23.</span></a> shows the callback to
<code class="docutils literal"><span class="pre">SimpleBLECentral_keyChangeHandler</span></code> when a key is pressed. This event is
placed into the application&#8217;s queue for processing.</p>
<div class="literal-block-wrapper docutils container" id="defining-simpleblecentral-keychangehandler">
<span id="board-key-change-handler-listing"></span><div class="code-block-caption"><span class="caption-number">Listing 9. </span><span class="caption-text">Defining SimpleBLECentral_keyChangeHandler()</span><a class="headerlink" href="#defining-simpleblecentral-keychangehandler" title="Permalink to this code">¶</a></div>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">SimpleBLECentral_keyChangeHandler</span><span class="p">(</span><span class="n">uint8</span> <span class="n">keys</span><span class="p">)</span>
<span class="p">{</span>
<span class="hll">  <span class="n">SimpleBLECentral_enqueueMsg</span><span class="p">(</span><span class="n">SBC_KEY_CHANGE_EVT</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class="p">}</span>
</pre></div>
</td></tr></table></div>
</div>
<p><strong>Step 2</strong> in <a class="reference internal" href="#fig-enqueue-message"><span class="std std-numref">Figure 23.</span></a> shows how this key press is enqueued
for simple_central. Here, memory is allocated from <a class="reference external" href="../../doxygen/group___i_call.html#ga00ce08b268a246cee700442af6ac10ec">ICall_malloc()</a> to be
added to the queue. Once added to the queue, <a class="reference external" href="../../doxygen/group___util.html#gada1270148b25421486d6a0f6e001a3b5">Util_enqueueMsg()</a> will
generate a <code class="xref c c-macro docutils literal"><span class="pre">UTIL_QUEUE_EVENT_ID</span></code> for the application to process.</p>
<div class="literal-block-wrapper docutils container" id="defining-simpleblecentral-enqueuemsg">
<div class="code-block-caption"><span class="caption-number">Listing 10. </span><span class="caption-text">Defining SimpleBLECentral_enqueueMsg()</span><a class="headerlink" href="#defining-simpleblecentral-enqueuemsg" title="Permalink to this code">¶</a></div>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">uint8_t</span> <span class="nf">SimpleBLECentral_enqueueMsg</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">event</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">state</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">pData</span><span class="p">)</span>
<span class="p">{</span>
<span class="hll">  <span class="n">sbcEvt_t</span> <span class="o">*</span><span class="n">pMsg</span> <span class="o">=</span> <span class="n">ICall_malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">sbcEvt_t</span><span class="p">));</span>
</span>
  <span class="c1">// Create dynamic pointer to message.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pMsg</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">pMsg</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">event</span> <span class="o">=</span> <span class="n">event</span><span class="p">;</span>
    <span class="n">pMsg</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">state</span><span class="p">;</span>
    <span class="n">pMsg</span><span class="o">-&gt;</span><span class="n">pData</span> <span class="o">=</span> <span class="n">pData</span><span class="p">;</span>

    <span class="c1">// Enqueue the message.</span>
<span class="hll">    <span class="k">return</span> <span class="n">Util_enqueueMsg</span><span class="p">(</span><span class="n">appMsgQueue</span><span class="p">,</span> <span class="n">sem</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="n">pMsg</span><span class="p">);</span>
</span>  <span class="p">}</span>

  <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="figure align-center" id="id42">
<span id="fig-dequeue-message"></span><p class="plantuml">
<img src="../_images/plantuml-cc1651df2b183e0c68107221b68856a96fb53245.png" alt="&#64;startuml
hide footbox

box &quot;Task context&quot;
    participant simple_central.c as A
    database appMsgQueue as B
end box

-&gt; A : Posted event
activate A

autonumber 3
A -&gt; A: while(!Queue_empty())
activate A

autonumber stop
A -&gt; B : Queue_empty()
activate B
B --&gt; A
deactivate B

A -&gt; B : pMsg = Util_dequeueMsg(appMsgQueue)
activate B
B --&gt; A
deactivate B

autonumber resume
A -&gt; : SipmleBLECentral_proccessAppMsg(pMsg);
note right: SipmleBLECentral_proccessAppMsg \n{\n\tcase (SBC_KEY_CHANGE_EVT):\n\t\tSimpleBLECentral_handleKeys()\n};
A -&gt; : ICall_free(pMsg)

autonumber stop
note right: Repeat while there are more messages\nin the queue
deactivate A

&#64;enduml" />
</p>
<p class="caption"><span class="caption-number">Figure 24. </span><span class="caption-text">Sequence diagram for dequeuing a message</span><a class="headerlink" href="#id42" title="Permalink to this image">¶</a></p>
</div>
<p><strong>Step 3</strong> in <a class="reference internal" href="#fig-dequeue-message"><span class="std std-numref">Figure 24.</span></a>, the simple_central application is
unblocked by the posted <code class="xref c c-macro docutils literal"><span class="pre">UTIL_QUEUE_EVENT_ID</span></code> event where it proceeds to
check if any messages have been placed in the queue for processing.</p>
<div class="literal-block-wrapper docutils container" id="processing-application-messages">
<div class="code-block-caption"><span class="caption-number">Listing 11. </span><span class="caption-text">Processing application messages</span><a class="headerlink" href="#processing-application-messages" title="Permalink to this code">¶</a></div>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">// If TI-RTOS queue is not empty, process app message</span>
<span class="hll"><span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">Queue_empty</span><span class="p">(</span><span class="n">appMsgQueue</span><span class="p">))</span>
</span><span class="p">{</span>
<span class="hll">  <span class="n">sbcEvt_t</span> <span class="o">*</span><span class="n">pMsg</span> <span class="o">=</span> <span class="p">(</span><span class="n">sbcEvt_t</span> <span class="o">*</span><span class="p">)</span><span class="n">Util_dequeueMsg</span><span class="p">(</span><span class="n">appMsgQueue</span><span class="p">);</span>
</span>  <span class="k">if</span> <span class="p">(</span><span class="n">pMsg</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// Process message</span>
<span class="hll">    <span class="n">SimpleBLECentral_processAppMsg</span><span class="p">(</span><span class="n">pMsg</span><span class="p">);</span>
</span>
    <span class="c1">// Free the space from the message</span>
<span class="hll">    <span class="n">ICall_free</span><span class="p">(</span><span class="n">pMsg</span><span class="p">);</span>
</span>  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</div>
<p><strong>Step 4</strong> in <a class="reference internal" href="#fig-dequeue-message"><span class="std std-numref">Figure 24.</span></a>, the simple_central application
takes the dequeue message and starts processing it.</p>
<div class="literal-block-wrapper docutils container" id="processing-key-interrupt-message">
<div class="code-block-caption"><span class="caption-number">Listing 12. </span><span class="caption-text">Processing key interrupt message</span><a class="headerlink" href="#processing-key-interrupt-message" title="Permalink to this code">¶</a></div>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">SimpleBLECentral_processAppMsg</span><span class="p">(</span><span class="n">sbcEvt_t</span> <span class="o">*</span><span class="n">pMsg</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">pMsg</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">event</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">case</span> <span class="nl">SBC_KEY_CHANGE_EVT</span><span class="p">:</span>
<span class="hll">      <span class="n">SimpleBLECentral_handleKeys</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pMsg</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">state</span><span class="p">);</span>
</span>      <span class="k">break</span><span class="p">;</span>
    <span class="c1">//...</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</div>
<p><strong>Step 5</strong> in <a class="reference internal" href="#fig-dequeue-message"><span class="std std-numref">Figure 24.</span></a>, the simple_central application
can now free the memory.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The Bluetooth low energy stack abstracts the Queue modules via the Util
module.</p>
</div>
</div>
</div>
</div>
<div class="section" id="tasks">
<span id="sec-rtos-overview-tasks"></span><h3>Tasks<a class="headerlink" href="#tasks" title="Permalink to this headline">¶</a></h3>
<p>TI-RTOS <em>Tasks</em> are equivalent to independent threads that conceptually execute
functions in parallel within a single C program. In reality, switching the
processor from one task to another helps achieve concurrency. Each task is
always in one of the following modes of execution:</p>
<ul class="simple">
<li><strong>Running</strong>: task is currently running</li>
<li><strong>Ready</strong>: task is scheduled for execution</li>
<li><strong>Blocked</strong>: task is suspended from execution</li>
<li><strong>Terminated</strong>: task is terminated from execution</li>
<li><strong>Inactive</strong>: task is on inactive list</li>
</ul>
<p>One (and only one) task is always running, even if it is only the idle task (see
<a class="reference internal" href="#tirtos-threads"><span class="std std-numref">Figure 19.</span></a>). The current running task can be blocked from
execution by calling certain task module functions, as well as functions
provided by other modules like Semaphores. The current task can also terminate
itself. In either case, the processor is switched to the highest priority task
that is ready to run. See the Task module in the package ti.sysbios.knl section
of the <a class="reference external" href="../../../../tirtos/sysbios/docs/Bios_User_Guide.pdf">TI-RTOS Kernel User Guide</a> for more information on these functions.</p>
<p>Numeric priorities are assigned to tasks, and multiple tasks can have the same
priority. Tasks are readied to execute by highest to lowest priority level;
tasks of the same priority are scheduled in order of arrival. The priority of
the currently running task is never lower than the priority of any ready task.
The running task is preempted and rescheduled to execute when there is a ready
task of higher priority.</p>
<p>In the simple_peripheral application, the Bluetooth low energy protocol
stack task is given the highest priority (5) and the application task is
given the lowest priority (1).</p>
<div class="section" id="initializing-a-task">
<span id="sec-rtos-overview-initializing-a-task"></span><h4>Initializing a Task<a class="headerlink" href="#initializing-a-task" title="Permalink to this headline">¶</a></h4>
<p>When a task is initialized, it has its own runtime stack for storing local
variables as well as further nesting of function calls. All tasks executing
within a single program share a common set of global variables, accessed
according to the standard rules of scope for C functions. This set of memory is
the context of the task. The following is an example of the application task
being constructed.</p>
<div class="literal-block-wrapper docutils container" id="a-ti-rtos-task">
<span id="creating-task-listing"></span><div class="code-block-caption"><span class="caption-number">Listing 13. </span><span class="caption-text">A TI-RTOS task</span><a class="headerlink" href="#a-ti-rtos-task" title="Permalink to this code">¶</a></div>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;xdc/std.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;ti/sysbios/BIOS.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;ti/sysbios/knl/Task.h&gt;</span><span class="cp"></span>

<span class="cm">/* Task&#39;s stack */</span>
<span class="kt">uint8_t</span> <span class="n">sbcTaskStack</span><span class="p">[</span><span class="n">TASK_STACK_SIZE</span><span class="p">];</span>

<span class="cm">/* Task object (to be constructed) */</span>
<span class="n">Task_Struct</span> <span class="n">task0</span><span class="p">;</span>

<span class="cm">/* Task function */</span>
<span class="hll"><span class="kt">void</span> <span class="nf">taskFunction</span><span class="p">(</span><span class="n">UArg</span> <span class="n">arg0</span><span class="p">,</span> <span class="n">UArg</span> <span class="n">arg1</span><span class="p">)</span>
</span><span class="hll"><span class="p">{</span>
</span><span class="hll">    <span class="cm">/* Local variables. Variables here go onto task stack!! */</span>
</span><span class="hll">
</span><span class="hll">    <span class="cm">/* Run one-time code when task starts */</span>
</span><span class="hll">
</span><span class="hll">    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="cm">/* Run loop forever (unless terminated) */</span>
</span><span class="hll">    <span class="p">{</span>
</span><span class="hll">        <span class="cm">/*</span>
</span><span class="hll"><span class="cm">         * Block on a signal or for a duration. Examples:</span>
</span><span class="hll"><span class="cm">         *  ``Sempahore_pend()``</span>
</span><span class="hll"><span class="cm">         *  ``Event_pend()``</span>
</span><span class="hll"><span class="cm">         *  ``Task_sleep()``</span>
</span><span class="hll"><span class="cm">         *</span>
</span><span class="hll"><span class="cm">         * &quot;Process data&quot;</span>
</span><span class="hll"><span class="cm">         */</span>
</span><span class="hll">    <span class="p">}</span>
</span><span class="hll"><span class="p">}</span>
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="n">Task_Params</span> <span class="n">taskParams</span><span class="p">;</span>

    <span class="c1">// Configure task</span>
    <span class="n">Task_Params_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">taskParams</span><span class="p">);</span>
    <span class="n">taskParams</span><span class="p">.</span><span class="n">stack</span> <span class="o">=</span> <span class="n">sbcTaskStack</span><span class="p">;</span>
    <span class="n">taskParams</span><span class="p">.</span><span class="n">stackSize</span> <span class="o">=</span> <span class="n">TASK_STACK_SIZE</span><span class="p">;</span>
    <span class="n">taskParams</span><span class="p">.</span><span class="n">priority</span> <span class="o">=</span> <span class="n">TASK_PRIORITY</span><span class="p">;</span>

<span class="hll">    <span class="n">Task_construct</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task0</span><span class="p">,</span> <span class="n">taskFunction</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">taskParams</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span>
    <span class="n">BIOS_start</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</div>
<p>The task creation is done in the main() function, before the TI-RTOS Kernel&#8217;s
scheduler is started by <code class="docutils literal"><span class="pre">BIOS_start()</span></code>. The task executes at its assigned
priority level after the scheduler is started.</p>
<p>TI recommends using an existing application task for application-specific
processing. When adding an additional task to the application project, the
priority of the task must be assigned a priority within the TI-RTOS
priority-level range, defined in the TI-RTOS configuration file (<code class="docutils literal"><span class="pre">.cfg</span></code>).</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p>Reduce the number of Task priority levels to gain additional RAM savings in
the TI-RTOS configuration file (<code class="docutils literal"><span class="pre">.cfg</span></code>):</p>
<div class="last highlight-c"><div class="highlight"><pre><span></span><span class="n">Task</span><span class="p">.</span><span class="n">numPriorities</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
</pre></div>
</div>
</div>
<p>Do not add a task with a priority equal to or higher than the Bluetooth low
energy protocol stack task and related supporting tasks (for example, the
GapRole task). See <a class="reference internal" href="#sec-inc-architecture-standard-project-task-hierarchy"><span class="std std-ref">Standard Project Task Hierarchy</span></a>
for details on the system task hierarchy.</p>
<p>Ensure the task has a minimum task stack size of 512 bytes of predefined memory.
At a minimum, each stack must be large enough to handle normal subroutine calls
and one task preemption context. A task preemption context is the context that
is saved when one task preempts another as a result of an interrupt thread
readying a higher priority task. Using the TI-RTOS profiling tools of the IDE,
the task can be analyzed to determine the peak task stack usage.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The term <em>created</em> describes the instantiation of a task. The actual TI-RTOS
method is to construct the task. See <a class="reference internal" href="#create-vs-construct"><span class="std std-ref">Creating vs. Constructing</span></a> for
details on constructing TI-RTOS objects.</p>
</div>
</div>
<div class="section" id="a-task-function">
<h4>A Task Function<a class="headerlink" href="#a-task-function" title="Permalink to this headline">¶</a></h4>
<p>When a task is initialized, a function pointer to a task function is passed to
the <code class="docutils literal"><span class="pre">Task_construct</span></code> function. When the task first gets a chance to process,
this is the function which the TI-RTOS runs. <a class="reference internal" href="#creating-task-listing"><span class="std std-numref">Listing 13.</span></a>
shows the general topology of this task function.</p>
<p>In typical use cases, the task spends most of its time in the blocked state,
where it calls a <code class="docutils literal"><span class="pre">_pend()</span></code> API such as <code class="docutils literal"><span class="pre">Semaphore_pend()</span></code>. Often,
high priority threads such as Hwis or Swis unblock the task with a <code class="docutils literal"><span class="pre">_post()</span></code>
API such as <code class="docutils literal"><span class="pre">Semaphore_post()</span></code>.</p>
</div>
</div>
<div class="section" id="clocks">
<h3>Clocks<a class="headerlink" href="#clocks" title="Permalink to this headline">¶</a></h3>
<p>Clock instances are functions that can be scheduled to run after a certain
number of system ticks. Clock instances are either one-shot or periodic. These
instances start immediately upon creation, are configured to start after a
delay, and can be stopped at any time. All clock instances are executed when
they expire in the context of a <a class="reference internal" href="glossary.html#term-swi"><span class="xref std std-term">Swi</span></a>. The following example shows the
minimum resolution is the TI-RTOS clock tick period set in the TI-RTOS
configuration file (<code class="docutils literal"><span class="pre">.cfg</span></code>).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The default TI-RTOS kernel tick period is 1 millisecond. For CC2640R2F
devices, this is reconfigured in the TI-RTOS configuration file (<code class="docutils literal"><span class="pre">.cfg</span></code>):</p>
<div class="last highlight-c"><div class="highlight"><pre><span></span><span class="n">Clock</span><span class="p">.</span><span class="n">tickPeriod</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</pre></div>
</div>
</div>
<p>Each system tick, which is derived from the real-time clock <a class="reference internal" href="glossary.html#term-rtc"><span class="xref std std-term">RTC</span></a>,
launches a Clock object that compares the running tick count with the period of
each clock to determine if the associated function should run. For
higher-resolution timers, TI recommends using a 16-bit hardware timer channel or
the sensor controller. See the Clock module in the package ti.sysbios.knl
section of the <a class="reference external" href="../../../../tirtos/sysbios/docs/Bios_User_Guide.pdf">TI-RTOS Kernel User Guide</a> for more information on these
functions.</p>
<p>You can use the Kernel&#8217;s Clock APIs directly in your application and in addition
the <code class="docutils literal"><span class="pre">Util</span></code> module also contains a set of abstracted TI-RTOS Clock functions as
shown here:</p>
<ul class="simple">
<li><a class="reference external" href="../../doxygen/group___util.html#ga761dca11dc0c6199168011949db793c5">Util_constructClock()</a> creates a clock object.</li>
<li><a class="reference external" href="../../doxygen/group___util.html#ga1c499454cba90c216ab2514b54f7ce88">Util_startClock()</a> starts an existing clock object.</li>
<li><a class="reference external" href="../../doxygen/group___util.html#ga3d36870c30686d68d7096fd333090c3f">Util_restartClock()</a> stops, restarts an existing clock object.</li>
<li><a class="reference external" href="../../doxygen/group___util.html#ga077436ed5f5a43a39f8c96cba253160e">Util_isActive()</a> checks if a clock object is running.</li>
<li><a class="reference external" href="../../doxygen/group___util.html#gae0a8cd00a21d57e55a96283336ceab17">Util_stopClock()</a> stop an existing clock object.</li>
<li><a class="reference external" href="../../doxygen/group___util.html#ga59503ce945c3762bb32e8a1e2cb9c8f9">Util_rescheduleClock()</a> reconfigure an existing clock object.</li>
</ul>
<div class="section" id="sec-rtos-overview-functional-clock-example">
<span id="id8"></span><h4>Functional Example<a class="headerlink" href="#sec-rtos-overview-functional-clock-example" title="Permalink to this headline">¶</a></h4>
<p>The following example was taken from the simple_peripheral project in
BLE-Stack 3.00.01.</p>
<div class="figure align-center" id="id43">
<span id="fig-periodic-clock"></span><p class="plantuml">
<img src="../_images/plantuml-a448b9966ee94238ca0a118e4cd245eca57f33da.png" alt="&#64;startuml
hide footbox

participant simple_perpherial.c as A
box &quot;Swi context&quot;
    participant &quot;Clock Object&quot; as B
end box

activate A
group Initialize Clock object
    autonumber
    A -&gt; B : Util_clockConstruct()
    autonumber stop
    A &lt;-- B
end

...

group Start Clock object
    A -&gt; B : Util_clockStart()

    B --&gt; A
    note left: Event_pend(event,...)

    deactivate A
end

...

group Clock function triggers after expiration
    autonumber resume
    rnote over B
        The Clock object invokes supplied function pointer
        (e.g. SimpleBLEPeripheral_performPeriodicTask())
        This function only posts a signal such as an Event
    end note
    B -&gt; B : SimpleBLEPeripheral_clockHandler();
    activate B
    autonumber stop
    B -&gt; : Event_post(event, SBP_PERIODIC_EVT);
    B &lt;--
    deactivate B
end

group Process period function and restart Clock object
    -&gt; A : Unblocked due to posted SBP_PERIODIC_EVT.
    activate A
    rnote over A
        Given that an event was posted, we can process the
        periodic function from a Task context
        (e.g. SimpleBLEPeripheral_performPeriodicTask())
    end note
    autonumber resume
    A -&gt; A : SimpleBLEPeripheral_performPeriodicTask()
    activate A

    rnote over A
        Restart the clock after the periodic process
    end note
    deactivate A
    autonumber stop
    A -&gt; B : Util_startClock();
    B --&gt; A

    deactivate A
    note left: Event_pend(event,...)
end

rnote over A, B
    The Clock object will trigger after
    expiration and the cycle will repeat itself.
end note

...

&#64;enduml" />
</p>
<p class="caption"><span class="caption-number">Figure 25. </span><span class="caption-text">Triggering clock objects</span><a class="headerlink" href="#id43" title="Permalink to this image">¶</a></p>
</div>
<p><strong>Step 1</strong> in <a class="reference internal" href="#fig-periodic-clock"><span class="std std-ref">Triggering clock objects</span></a> constructs the Clock object via
<a class="reference external" href="../../doxygen/group___util.html#ga761dca11dc0c6199168011949db793c5">Util_constructClock()</a>. After the example entered a connected state, it
will then start the clock object via a <a class="reference external" href="../../doxygen/group___util.html#ga1c499454cba90c216ab2514b54f7ce88">Util_startClock()</a>.</p>
<div class="literal-block-wrapper docutils container" id="constructing-periodicclock-clock-object-in-simple-peripheral">
<div class="code-block-caption"><span class="caption-number">Listing 14. </span><span class="caption-text">Constructing <code class="docutils literal"><span class="pre">periodicClock</span></code> Clock object in simple_peripheral</span><a class="headerlink" href="#constructing-periodicclock-clock-object-in-simple-peripheral" title="Permalink to this code">¶</a></div>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="c1">// Clock instances for internal periodic events.</span>
<span class="hll"><span class="k">static</span> <span class="n">Clock_Struct</span> <span class="n">periodicClock</span><span class="p">;</span>
</span>
<span class="c1">// Create one-shot clocks for internal periodic events.</span>
<span class="hll"><span class="n">Util_constructClock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">periodicClock</span><span class="p">,</span> <span class="n">SimpleBLEPeripheral_clockHandler</span><span class="p">,</span>
</span><span class="hll">    <span class="n">SBP_PERIODIC_EVT_PERIOD</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">SBP_PERIODIC_EVT</span><span class="p">);</span>
</span></pre></div>
</div>
</div>
<p><strong>Step 2</strong> in <a class="reference internal" href="#fig-periodic-clock"><span class="std std-ref">Triggering clock objects</span></a>, after the Clock object&#8217;s timer expired,
it will execute <code class="docutils literal"><span class="pre">SimpleBLEPeripheral_clockHandler()</span></code> within a Swi context. As
this call cannot be blocked and blocks all Tasks, it is kept short by invoking
an <code class="docutils literal"><span class="pre">Event_post(SBP_PERIODIC_EVT)</span></code> for post processing in simple_peripheral.</p>
<div class="literal-block-wrapper docutils container" id="defining-simplebleperipheral-clockhandler">
<div class="code-block-caption"><span class="caption-number">Listing 15. </span><span class="caption-text">Defining SimpleBLEPeripheral_clockHandler()</span><a class="headerlink" href="#defining-simplebleperipheral-clockhandler" title="Permalink to this code">¶</a></div>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">SimpleBLEPeripheral_clockHandler</span><span class="p">(</span><span class="n">UArg</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* arg is passed in from Clock_construct() */</span>
<span class="hll">    <span class="n">Event_post</span><span class="p">(</span><span class="n">events</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="admonition attention">
<p class="first admonition-title">Attention</p>
<p class="last">Clock functions must not call blocking kernel APIs or TI-RTOS driver APIs!
Executing long routines will impact real-time constraints placed in high
priority tasks allocated for wireless protocol stacks!</p>
</div>
<p><strong>Step 3</strong> in <a class="reference internal" href="#fig-periodic-clock"><span class="std std-ref">Triggering clock objects</span></a>, the simple_peripheral task is
unblocked due the <code class="docutils literal"><span class="pre">Event_post(SBP_PERIODIC_EVT)</span></code>, where it proceeds to invoke
the <code class="docutils literal"><span class="pre">SimpleBLEPeripheral_performPeriodicTask()</span></code> function. Afterwards, to
restart the periodic execution of this function, it will restart the
<code class="docutils literal"><span class="pre">periodicClock</span></code> Clock object.</p>
<div class="literal-block-wrapper docutils container" id="servicing-the-sbp-periodic-evt-event">
<div class="code-block-caption"><span class="caption-number">Listing 16. </span><span class="caption-text">Servicing the SBP_PERIODIC_EVT event</span><a class="headerlink" href="#servicing-the-sbp-periodic-evt-event" title="Permalink to this code">¶</a></div>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">SBP_PERIODIC_EVT</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Perform periodic application task</span>
<span class="hll">  <span class="n">SimpleBLEPeripheral_performPeriodicTask</span><span class="p">();</span>
</span>
<span class="hll">  <span class="n">Util_startClock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">periodicClock</span><span class="p">);</span>
</span><span class="p">}</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="drivers">
<span id="tirtos-drivers"></span><span id="peripherals-and-drivers"></span><h3>Drivers<a class="headerlink" href="#drivers" title="Permalink to this headline">¶</a></h3>
<p>The TI-RTOS provides a suite of CC26xx peripheral drivers that can
be added to an application. The drivers provide a mechanism for the
application to interface with the CC26xx onboard peripherals and
communicate with external devices. These drivers make use of
DriverLib to abstract register access.</p>
<p>There is significant documentation relating to each TI-RTOS driver
located in the BLE-Stack. Refer to the BLE-Stack
release notes for the specific location. This section only
provides an overview of how drivers fit into the software ecosystem.
For a description of available features and driver APIs, refer to
the TI-RTOS API Reference.</p>
<div class="section" id="adding-a-driver">
<span id="id9"></span><h4>Adding a Driver<a class="headerlink" href="#adding-a-driver" title="Permalink to this headline">¶</a></h4>
<p>Some of the drivers are added to the project as source files in their
respective folder under the Drivers folder in the project workspace,
as shown in <a class="reference internal" href="#drivers-folder"><span class="std std-numref">Figure 26.</span></a></p>
<div class="figure align-center" id="id44">
<span id="drivers-folder"></span><img alt="../_images/drivers_folder.jpg" src="../_images/drivers_folder.jpg" />
<p class="caption"><span class="caption-number">Figure 26. </span><span class="caption-text">Drivers Folder</span></p>
</div>
<p>The driver source files can be found in their respective folder at
<em>$TI_RTOS_DRIVERS_BASE$\ti\drivers</em>.</p>
<p>The $TI_RTOS_DRIVERS_BASE$ argument variable refers to the
installation location and can be viewed in IAR Tools\
Configure Custom Argument Variables menu. For CCS, the corresponding
path variables are defined in the Project Options\
Resource\Linked Resources, Path Variables tab.</p>
<p>The ECC and TRNG drivers, for example, are part of the BLE-Stack, not the TIRTOS, and they are
located at
<em>&lt;SDK_INSTALL_DIR&gt;\source\ti\blestack\common\cc26xx\ecc</em>
and
<em>&lt;SDK_INSTALL_DIR&gt;\source\ti\blestack\hal\src\target\_common</em> respectively.</p>
<p>To add a driver to a project, include the C and include file of the
respective driver in the application file (or files) where the
driver APIs are referenced.</p>
<p>For example, to add the PIN driver for reading or controlling an
output I/O pin, add the following:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;ti/drivers/pin/PINCC26XX.h&gt;</span><span class="cp"></span>
</pre></div>
</div>
<p>Also add the following TI-RTOS driver files to the project under the
Drivers\PIN folder:</p>
<ul class="simple">
<li>PINCC26XX.c</li>
<li>PINCC26XX.h</li>
<li>PIN.h</li>
</ul>
<p>This is described in more detail in the following sections.</p>
</div>
<div class="section" id="board-file">
<h4>Board File<a class="headerlink" href="#board-file" title="Permalink to this headline">¶</a></h4>
<p>The board file sets the parameters of the fixed driver configuration
for a specific board configuration, such as configuring the GPIO
table for the PIN driver or defining which pins are allocated to the
I2C, SPI, or UART driver.</p>
<p>See the <a class="reference internal" href="../ble-stack/index.html#board-file"><span class="std std-ref">TI Provided Board Files</span></a> section for more information on board files and how to
switch between TI EMs and LPs or port to custom hardware.</p>
</div>
<div class="section" id="available-drivers">
<h4>Available Drivers<a class="headerlink" href="#available-drivers" title="Permalink to this headline">¶</a></h4>
<p>This section describes each available driver and provides a basic
example of adding the driver to the simple_peripheral project. For
more detailed information on each driver, see the TI-RTOS API
Reference.</p>
<div class="section" id="pin">
<h5>PIN<a class="headerlink" href="#pin" title="Permalink to this headline">¶</a></h5>
<p>The PIN driver allows control of the I/O pins for
software-controlled general-purpose I/O (GPIO) or connections to
hardware peripherals. As stated in the <a class="reference internal" href="../ble-stack/index.html#board-file"><span class="std std-ref">TI Provided Board Files</span></a> section,
the pins must first be initialized to a safe state (configured in the board
file) in main(). After this initialization, any module can use the PIN
driver to configure a set of pins for use. The following is an
example of configuring the simple_peripheral task to use one pin as
an interrupt and another as an output, to toggle when the interrupt
occurs. IOID_x pin numbers map to DIO pin numbers as referenced in
<a class="reference external" href="http://www.ti.com/lit/pdf/swcu117">CC26xx Technical Reference Manual</a>. The following
table lists pins used and their mapping on the CC2640R2F LaunchPad.
These are already defined in the board file.</p>
<table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="20%" />
<col width="35%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Signal Name</th>
<th class="head">Pin ID</th>
<th class="head">CC2640R2F LaunchPad Mapping</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CC2640R2_LAUNCHXL_PIN_RLED</td>
<td>IOID_6</td>
<td>DIO6 (Red)</td>
</tr>
<tr class="row-odd"><td>CC2640R2_LAUNCHXL_PIN_BTN1</td>
<td>IOID_13</td>
<td>DIO13 (BTN_1)</td>
</tr>
</tbody>
</table>
<p>The following simple_peripheral.c code modifications are required.</p>
<ol class="arabic">
<li><p class="first">Include PIN driver files:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;ti/drivers/pin/PINCC26xx.h&gt;</span><span class="cp"></span>
</pre></div>
</div>
</li>
<li><p class="first">Declare the pin configuration table and pin state and handle
variables to be used by the simple_peripheral task:</p>
<blockquote>
<div><div class="literal-block-wrapper docutils container" id="pin-configuration-table">
<span id="lst-peripheral-and-drivers-pin-configuration-table"></span><div class="code-block-caption"><span class="caption-number">Listing 17. </span><span class="caption-text">Pin configuration table</span><a class="headerlink" href="#pin-configuration-table" title="Permalink to this code">¶</a></div>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">PIN_Config</span> <span class="n">SBP_configTable</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="n">CC2640R2_LAUNCHXL_PIN_RLED</span> <span class="o">|</span> <span class="n">PIN_GPIO_OUTPUT_EN</span> <span class="o">|</span> <span class="n">PIN_GPIO_LOW</span> <span class="o">|</span> <span class="n">PIN_PUSHPULL</span> <span class="o">|</span> <span class="n">PIN_DRVSTR_MAX</span><span class="p">,</span>
    <span class="n">CC2640R2_LAUNCHXL_PIN_BTN1</span> <span class="o">|</span> <span class="n">PIN_INPUT_EN</span> <span class="o">|</span> <span class="n">PIN_PULLUP</span> <span class="o">|</span> <span class="n">PIN_IRQ_BOTHEDGES</span> <span class="o">|</span> <span class="n">PIN_HYSTERESIS</span><span class="p">,</span>
    <span class="n">PIN_TERMINATE</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">PIN_State</span> <span class="n">sbpPins</span><span class="p">;</span>
<span class="k">static</span> <span class="n">PIN_Handle</span> <span class="n">hSbpPins</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">uint8_t</span> <span class="n">LED_value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
</div>
</div></blockquote>
</li>
<li><p class="first">Declare the ISR to be performed in the Hwi context:</p>
<div class="literal-block-wrapper docutils container" id="isr-code">
<div class="code-block-caption"><span class="caption-number">Listing 18. </span><span class="caption-text">Declare the ISR</span><a class="headerlink" href="#isr-code" title="Permalink to this code">¶</a></div>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">buttonHwiFxn</span><span class="p">(</span><span class="n">PIN_Handle</span> <span class="n">hPin</span><span class="p">,</span> <span class="n">PIN_Id</span> <span class="n">pinId</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">SimpleBLEPeripheral_enqueueMsg</span><span class="p">(</span><span class="n">SBP_BTN_EVT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</li>
<li><p class="first">In SimpleBLEPeripheral_processAppMsg, add a case to handle the event from
above, and define the event:</p>
<blockquote>
<div><div class="literal-block-wrapper docutils container" id="processing-of-isr-event">
<span id="lst-peripheral-and-drivers-process-isr"></span><div class="code-block-caption"><span class="caption-number">Listing 19. </span><span class="caption-text">Processing of ISR event</span><a class="headerlink" href="#processing-of-isr-event" title="Permalink to this code">¶</a></div>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#define SBP_BTN_EVT</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">SimpleBLEPeripheral_processAppMsg</span><span class="p">(</span><span class="n">sbcEvt_t</span> <span class="o">*</span><span class="n">pMsg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">pMsg</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">event</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">case</span> <span class="nl">SBP_BTN_EVT</span><span class="p">:</span>
            <span class="c1">//toggle red LED</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">LED_value</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">PIN_setOutputValue</span><span class="p">(</span><span class="n">hSbpPins</span><span class="p">,</span> <span class="n">CC2640R2_LAUNCHXL_PIN_RLED</span> <span class="p">,</span> <span class="n">LED_value</span><span class="o">--</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="n">PIN_setOutputValue</span><span class="p">(</span><span class="n">hSbpPins</span><span class="p">,</span> <span class="n">CC2640R2_LAUNCHXL_PIN_RLED</span><span class="p">,</span> <span class="n">LED_value</span><span class="o">++</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">break</span><span class="p">;</span>
            <span class="c1">//...</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div></blockquote>
</li>
<li><p class="first">Open the pins for use and configure the interrupt in
simple_peripheral_init():</p>
<div class="literal-block-wrapper docutils container" id="open-the-pins-and-configure-the-interrupt">
<span id="lst-peripheral-and-drivers-open-pins"></span><div class="code-block-caption"><span class="caption-number">Listing 20. </span><span class="caption-text">Open the pins and configure the interrupt</span><a class="headerlink" href="#open-the-pins-and-configure-the-interrupt" title="Permalink to this code">¶</a></div>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="c1">// Open pin structure for use</span>
<span class="n">hSbpPins</span> <span class="o">=</span> <span class="n">PIN_open</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbpPins</span><span class="p">,</span> <span class="n">SBP_configTable</span><span class="p">);</span>
<span class="c1">// Register ISR</span>
<span class="n">PIN_registerIntCb</span><span class="p">(</span><span class="n">hSbpPins</span><span class="p">,</span> <span class="n">buttonHwiFxn</span><span class="p">);</span>
<span class="c1">// Configure interrupt</span>
<span class="n">PIN_setConfig</span><span class="p">(</span><span class="n">hSbpPins</span><span class="p">,</span> <span class="n">PIN_BM_IRQ</span><span class="p">,</span> <span class="n">CC2640R2_LAUNCHXL_PIN_BTN1</span> <span class="o">|</span> <span class="n">PIN_IRQ_NEGEDGE</span><span class="p">);</span>
<span class="c1">// Enable wakeup</span>
<span class="n">PIN_setConfig</span><span class="p">(</span><span class="n">hSbpPins</span><span class="p">,</span> <span class="n">PINCC26XX_BM_WaKEUP</span><span class="p">,</span> <span class="n">CC2640R2_LAUNCHXL_PIN_BTN1</span><span class="o">|</span><span class="n">PINCC26XX_WAKEUP_NEGEDGE</span><span class="p">);</span>
</pre></div>
</div>
</div>
</li>
<li><p class="first">Compile</p>
</li>
<li><p class="first">Download</p>
</li>
<li><p class="first">Run</p>
</li>
</ol>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Pushing the BTN-1 button on the CC2640R2F LaunchPad toggles the red LED.
No debouncing is implemented.</p>
</div>
</div>
<div class="section" id="gpio">
<h5>GPIO<a class="headerlink" href="#gpio" title="Permalink to this headline">¶</a></h5>
<p>The GPIO module allows you to manage General Purpose I/O pins via simple and
portable APIs. GPIO pin behavior is usually configured statically, but can also
be configured or reconfigured at runtime.</p>
<p>Because of its simplicity, the GPIO driver does not follow the model of other
TI-RTOS drivers in which a driver application interface has separate
device-specific implementations. This difference is most apparent in the
GPIOxxx_Config structure, which does not require you to specify a particular
function table or object.</p>
<p>The following is an example of how to configure a GPIO pin to generate and
interrupt and how to toggle an LED on and off within the registered interrupt
callback function in Simple Peripheral.</p>
<ol class="arabic">
<li><p class="first">Include GPIO driver files in simple_peripheral.c:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;ti/drivers/GPIO.h&gt;</span><span class="cp"></span>
</pre></div>
</div>
</li>
</ol>
<p>The following must be added to Board.c:</p>
<ol class="arabic" start="2">
<li><p class="first">An array of GPIO_PinConfig elements that defines the initial configuration of
each pin used by the application. The pin type (that is, INPUT/OUTPUT), its
initial state (that is OUTPUT_HIGH or LOW), interrupt behavior
(RISING/FALLING edge, etc.), and device specific pin identification are
configured in each element of this array. Below is a CC26XX device specific
example of the GPIO_PinConfig array:</p>
<div class="literal-block-wrapper docutils container" id="set-up-the-gpio-pin-config-array">
<span id="lst-gpio-pin-config-array"></span><div class="code-block-caption"><span class="caption-number">Listing 21. </span><span class="caption-text">Set up the GPIO pin config array</span><a class="headerlink" href="#set-up-the-gpio-pin-config-array" title="Permalink to this code">¶</a></div>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="c1">//</span>
<span class="c1">// Array of Pin configurations</span>
<span class="c1">// NOTE: The order of the pin configurations must coincide with what was</span>
<span class="c1">//       defined in CC2640R2_LAUNCH.h</span>
<span class="c1">// NOTE: Pins not used for interrupts should be placed at the end of the</span>
<span class="c1">//       array.  Callback entries can be omitted from callbacks array to</span>
<span class="c1">//       reduce memory usage.</span>
<span class="c1">//</span>
<span class="n">GPIO_PinConfig</span> <span class="n">gpioPinConfigs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="c1">// Input pins</span>
    <span class="n">GPIOCC26XX_DIO_13</span> <span class="o">|</span> <span class="n">GPIO_CFG_IN_PU</span> <span class="o">|</span> <span class="n">GPIO_CFG_IN_INT_RISING</span><span class="p">,</span>  <span class="c1">// Button 0</span>
    <span class="n">GPIOCC26XX_DIO_14</span> <span class="o">|</span> <span class="n">GPIO_CFG_IN_PU</span> <span class="o">|</span> <span class="n">GPIO_CFG_IN_INT_RISING</span><span class="p">,</span>  <span class="c1">// Button 1</span>
    <span class="c1">// Output pins</span>
    <span class="n">GPIOCC26XX_DIO_07</span> <span class="o">|</span> <span class="n">GPIO_CFG_OUT_STD</span> <span class="o">|</span> <span class="n">GPIO_CFG_OUT_STR_HIGH</span> <span class="o">|</span> <span class="n">GPIO_CFG_OUT_LOW</span><span class="p">,</span>     <span class="c1">//  Green LED</span>
    <span class="n">GPIOCC26XX_DIO_06</span> <span class="o">|</span> <span class="n">GPIO_CFG_OUT_STD</span> <span class="o">|</span> <span class="n">GPIO_CFG_OUT_STR_HIGH</span> <span class="o">|</span> <span class="n">GPIO_CFG_OUT_LOW</span><span class="p">,</span>     <span class="c1">//  Red LED</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
</li>
<li><p class="first">An array of GPIO_CallbackFxn elements that is used to store callback function
pointers for GPIO pins configured with interrupts. The indexes for these
array elements correspond to the pins defined in the GPIO_PinConfig array.
These function pointers can be defined statically by referencing the callback
function name in the array element, or dynamically, by setting the array
element to NULL and using GPIO_setCallback() at runtime to plug the callback
entry. Pins not used for interrupts can be omitted from the callback array to
reduce memory usage (if they are placed at the end of the GPIO_PinConfig
array). The callback function syntax should match the following:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">GPIO_CallbackFxn</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">);</span>
</pre></div>
</div>
<p>The index parameter is the same index that was passed to GPIO_setCallback().
This allows the same callback function to be used for multiple GPIO
interrupts, by using the index to identify the GPIO that caused the
interrupt. Below is an CC26XX device specific example of the GPIO_CallbackFxn
array:</p>
<div class="literal-block-wrapper docutils container" id="set-up-the-gpio-callback-function-array">
<span id="lst-gpio-callback-fxn-array"></span><div class="code-block-caption"><span class="caption-number">Listing 22. </span><span class="caption-text">Set up the GPIO callback function array</span><a class="headerlink" href="#set-up-the-gpio-callback-function-array" title="Permalink to this code">¶</a></div>
<div class="highlight-c"><div class="highlight"><pre><span></span> <span class="c1">//</span>
 <span class="c1">// Array of callback function pointers</span>
 <span class="c1">// NOTE: The order of the pin configurations must coincide with what was</span>
 <span class="c1">//       defined in CC2640R2_LAUNCH.h</span>
 <span class="c1">// NOTE: Pins not used for interrupts can be omitted from callbacks array to</span>
 <span class="c1">//       reduce memory usage (if placed at end of gpioPinConfigs array).</span>
 <span class="c1">//</span>
 <span class="n">GPIO_CallbackFxn</span> <span class="n">gpioCallbackFunctions</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
     <span class="nb">NULL</span><span class="p">,</span>  <span class="c1">//  Button 0</span>
     <span class="nb">NULL</span><span class="p">,</span>  <span class="c1">//  Button 1</span>
 <span class="p">};</span>
</pre></div>
</div>
</div>
</li>
<li><p class="first">The device specific GPIOCC26XX_Config structure tells the GPIO driver
where the two aforementioned arrays are and the number of elements in each.
The interrupt priority of all pins configured to generate interrupts is also
specified here. Values for the interrupt priority are device-specific. You
should be well-acquainted with the interrupt controller used in your device
before setting this parameter to a non-default value. The sentinel value of
(~0) (the default value) is used to indicate that the lowest possible
priority should be used. Below is an example of an initialized
GPIOCC26XX_Config structure:</p>
<div class="literal-block-wrapper docutils container" id="set-up-the-gpio-config-structure">
<span id="lst-gpio-config-structure"></span><div class="code-block-caption"><span class="caption-number">Listing 23. </span><span class="caption-text">Set up the GPIO config structure</span><a class="headerlink" href="#set-up-the-gpio-config-structure" title="Permalink to this code">¶</a></div>
<div class="highlight-c"><div class="highlight"><pre><span></span> <span class="k">const</span> <span class="n">GPIOCC26XX_Config</span> <span class="n">GPIOCC26XX_config</span> <span class="o">=</span> <span class="p">{</span>
      <span class="p">.</span><span class="n">pinConfigs</span> <span class="o">=</span> <span class="p">(</span><span class="n">GPIO_PinConfig</span> <span class="o">*</span><span class="p">)</span><span class="n">gpioPinConfigs</span><span class="p">,</span>
      <span class="p">.</span><span class="n">callbacks</span> <span class="o">=</span> <span class="p">(</span><span class="n">GPIO_CallbackFxn</span> <span class="o">*</span><span class="p">)</span><span class="n">gpioCallbackFunctions</span><span class="p">,</span>
      <span class="p">.</span><span class="n">numberOfPinConfigs</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">gpioPinConfigs</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">GPIO_PinConfig</span><span class="p">),</span>
      <span class="p">.</span><span class="n">numberOfCallbacks</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">gpioCallbackFunctions</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">GPIO_CallbackFxn</span><span class="p">),</span>
      <span class="p">.</span><span class="n">intPriority</span> <span class="o">=</span> <span class="p">(</span><span class="o">~</span><span class="mi">0</span><span class="p">)</span>
  <span class="p">};</span>
</pre></div>
</div>
</div>
</li>
</ol>
<p>Add the following to simple_peripheral.c:</p>
<ol class="arabic" start="5">
<li><p class="first">The button callback function:</p>
<div class="literal-block-wrapper docutils container" id="set-up-the-button-callback-function">
<span id="lst-button-callback-fxn"></span><div class="code-block-caption"><span class="caption-number">Listing 24. </span><span class="caption-text">Set up the button callback function</span><a class="headerlink" href="#set-up-the-button-callback-function" title="Permalink to this code">¶</a></div>
<div class="highlight-c"><div class="highlight"><pre><span></span> <span class="c1">//</span>
 <span class="c1">//  ======== gpioButtonFxn0 ========</span>
 <span class="c1">//  Callback function for the GPIO interrupt on CC2640R2_LAUNCHXL_PIN_BTN1.</span>
 <span class="c1">//</span>
 <span class="kt">void</span> <span class="nf">gpioButtonFxn0</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
 <span class="p">{</span>
     <span class="c1">// Toggle the LED</span>
     <span class="n">GPIO_toggle</span><span class="p">(</span><span class="n">CC2640R2_LAUNCHXL_PIN_BTN1</span><span class="p">);</span>
 <span class="p">}</span>
</pre></div>
</div>
</div>
</li>
<li><p class="first">Initialization and use of the GPIOs (add this to simple_peripheral_init()):</p>
<div class="literal-block-wrapper docutils container" id="initialize-and-use-gpios">
<span id="lst-initialize-use-gpios"></span><div class="code-block-caption"><span class="caption-number">Listing 25. </span><span class="caption-text">Initialize and use GPIOs</span><a class="headerlink" href="#initialize-and-use-gpios" title="Permalink to this code">¶</a></div>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="c1">// Call GPIO driver init function</span>
<span class="n">GPIO_init</span><span class="p">();</span>

<span class="c1">// Turn on user LED</span>
<span class="n">GPIO_write</span><span class="p">(</span><span class="n">CC2640R2_LAUNCHXL_PIN_RLED</span><span class="p">,</span> <span class="n">Board_GPIO_LED_ON</span><span class="p">);</span>

<span class="c1">// install Button callback</span>
<span class="n">GPIO_setCallback</span><span class="p">(</span><span class="n">CC2640R2_LAUNCHXL_PIN_BTN1</span><span class="p">,</span> <span class="n">gpioButtonFxn0</span><span class="p">);</span>

<span class="c1">// Enable interrupts</span>
<span class="n">GPIO_enableInt</span><span class="p">(</span><span class="n">CC2640R2_LAUNCHXL_PIN_BTN1</span><span class="p">);</span>
</pre></div>
</div>
</div>
</li>
<li><p class="first">Compile</p>
</li>
<li><p class="first">Download</p>
</li>
<li><p class="first">Run</p>
</li>
</ol>
</div>
<div class="section" id="other-drivers">
<h5>Other Drivers<a class="headerlink" href="#other-drivers" title="Permalink to this headline">¶</a></h5>
<p>The other drivers included with TI-RTOS are: UART, SPI, Crypto (AES), I2C,
PDM, Power, RF, and UDMA. The stack makes use of the power, RF, and
UDMA, so extra care must be taken if using these. As with the other
drivers, these are well-documented, and examples are provided in the
BLE-Stack.</p>
</div>
</div>
</div>
<div class="section" id="power-management">
<h3>Power Management<a class="headerlink" href="#power-management" title="Permalink to this headline">¶</a></h3>
<p>All power-management functionality is handled by the peripheral
drivers and the Bluetooth low energy protocol stack. This feature
can be enabled or disabled by including or excluding the
POWER_SAVING preprocessor-defined symbol. When POWER_SAVING is
enabled, the device enters and exits sleep as required for Bluetooth
low energy events, peripheral events, application timers, and so
forth. When POWER_SAVING is undefined, the device stays awake. See
<a class="reference internal" href="#sec-developing-with-ccs-accessing-preprocessor-symbols"><span class="std std-ref">Accessing Preprocessor Symbols</span></a> in CCS or
<a class="reference internal" href="#sec-developing-with-iar-accessing-preprocessor-symbols"><span class="std std-ref">Accessing Preprocessor Symbols</span></a> in IAR for steps
to modify preprocessor-defined symbols.</p>
<p>More information on power-management functionality, including the
API and a sample use case for a custom UART driver, can be found in
the TI-RTOS Power Management for CC26xx included in the TI-RTOS
install. These APIs are required only when using a custom driver.</p>
<p>Also see <em>Measuring Bluetooth Smart Power Consumption</em> (SWRA478) for
steps to analyze the system power consumption and battery life.</p>
</div>
</div>
<div class="section" id="memory-management">
<h2>Memory Management<a class="headerlink" href="#memory-management" title="Permalink to this headline">¶</a></h2>
<div class="section" id="flash">
<span id="id10"></span><h3>Flash<a class="headerlink" href="#flash" title="Permalink to this headline">¶</a></h3>
<p>The flash is split into erasable pages of 4kB. The various sections
of flash and their associate linker files are as follows.</p>
<ul class="simple">
<li><strong>Simple NV (SNV) Area</strong>: used for nonvolatile memory storage by the GAP
Bond Manager and also available for use by the application. See
<a class="reference internal" href="#using-simple-nv"><span class="std std-ref">Using Simple NV for Flash Storage</span></a> for configuring SNV. When configured, the SNV
flash storage area is part of the stack image.</li>
<li><strong>Customer Configuration Area</strong> (<a class="reference internal" href="glossary.html#term-cca"><span class="xref std std-term">CCA</span></a>): the last sector of flash used
to store customer-specific chip configuration (<a class="reference internal" href="glossary.html#term-ccfg"><span class="xref std std-term">CCFG</span></a>) parameters. The
unused space of the CCA sector is allocated to the application project.
See <a class="reference internal" href="#cca"><span class="std std-ref">Customer Configuration Area</span></a>.</li>
</ul>
<p>For projects where the stack project builds a <strong>library</strong>:</p>
<ul class="simple">
<li><strong>Application Image Code Space</strong>: used for the application project. This
image is configured in the linker configuration file of the application:
cc26xx_app.icf (IAR) and cc26xx_app.cmd (CCS).</li>
</ul>
<p>For <strong>split image</strong> projects:</p>
<ul class="simple">
<li><strong>Application Image Code Space</strong>: used for the application project. This
image is configured in the linker configuration file of the application:
cc26xx_app.icf (IAR) and cc26xx_app.cmd (CCS).</li>
<li><strong>Stack Image Code Space</strong>: use for the stack project. This image is
configured in the linker configuration file of the stack:
cc26xx_stack.icf (IAR) and cc26xx_ stack.cmd (CCS).</li>
</ul>
<div class="section" id="flash-memory-map">
<h4>Flash Memory Map<a class="headerlink" href="#flash-memory-map" title="Permalink to this headline">¶</a></h4>
<p>This section describes the flash memory map at the system level for
<strong>split image</strong> project configurations. As <a class="reference internal" href="#fig-flash-memory-map"><span class="std std-numref">Figure 27.</span></a> shows,
the application linker file point to symbols with a solid arrow and the stack
linker file point to symbols with a dashed arrow.</p>
<div class="figure align-center" id="id45">
<span id="fig-flash-memory-map"></span><img alt="../_images/flashmemorymap.png" src="../_images/flashmemorymap.png" />
<p class="caption"><span class="caption-number">Figure 27. </span><span class="caption-text">System Flash Map</span></p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Projects that include the stack as a library, the <strong>Application Image Code
Space</strong> and <strong>Stack Image Code Space</strong> are combined in the <strong>Application
Image Code Space</strong> without any boundary requirements associated with <strong>split
images</strong>.</p>
</div>
<p><a class="reference internal" href="#flash-system-map"><span class="std std-numref">Table 8.</span></a> summarizes the Flash System Map definitions from
<a class="reference internal" href="#fig-flash-memory-map"><span class="std std-numref">Figure 27.</span></a> and provides the associated linker definitions
or symbols that can be found in the respective IDE linker files.</p>
<table border="1" class="docutils" id="id46">
<span id="flash-system-map"></span><caption><span class="caption-number">Table 8. </span><span class="caption-text">Flash System Map Definitions</span><a class="headerlink" href="#id46" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="18%" />
<col width="28%" />
<col width="12%" />
<col width="23%" />
<col width="19%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>Symbol/Region</strong></td>
<td><strong>Meaning</strong></td>
<td><strong>Project</strong></td>
<td><strong>CCS Definition</strong></td>
<td><strong>IAR Definition</strong></td>
</tr>
<tr class="row-even"><td>APP_FLASH_START</td>
<td>Start of flash/Start of App code
image</td>
<td>App</td>
<td>FLASH_APP_BASE</td>
<td>FLASH_START</td>
</tr>
<tr class="row-odd"><td>APP_FLASH_END</td>
<td>End of App code image.
(ICALL_STACK0_ADDR-1)</td>
<td>App</td>
<td>ADJ_ICALL_STACK0_START
- FLASH_APP_BASE</td>
<td>FLASH_END</td>
</tr>
<tr class="row-even"><td>STACK_FLASH_START</td>
<td>Start of Stack code image
(ICALL_STACK0_ADDR)</td>
<td>Stack</td>
<td colspan="2">FLASH_START</td>
</tr>
<tr class="row-odd"><td>STACK_FLASH_END</td>
<td>End of Stack flash code image,
including SNV</td>
<td>Stack</td>
<td>FLASH_SIZE -
RESERVED_SIZE</td>
<td>FLASH_END</td>
</tr>
<tr class="row-even"><td>CCA sector</td>
<td>Last sector of flash. Contains
the CCFG.</td>
<td>App</td>
<td colspan="2">FLASH_LAST_PAGE</td>
</tr>
<tr class="row-odd"><td>CCFG region</td>
<td>Location in CCA where
Customer Configuration (CCFG)
parameters are stored</td>
<td>App</td>
<td colspan="2">Last 88 bytes (sizeof(ccfg_t) of CCA</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="application-and-stack-flash-boundary">
<h4>Application and Stack Flash Boundary<a class="headerlink" href="#application-and-stack-flash-boundary" title="Permalink to this headline">¶</a></h4>
<p>The application and stack code images are based on the common
ICALL_STACK0_ADDR and ICALL_STACK0_START predefined symbols. These values
define the hard-coded flash address of the entry function for the stack image: it
is essentially the word-aligned flash address of the application-stack project
boundary. To ensure proper linking, both the application and stack projects must
use the same defined symbols. By default, the linker is configured to allocate
unused flash to the application project but can be modified manually or
automatically through the frontier tool. For information on using the frontier
tool to configure the flash boundary address, see <a class="reference internal" href="#sec-fontier-tool"><span class="std std-ref">Frontier Tool Operation</span></a>.</p>
</div>
<div class="section" id="using-simple-nv-for-flash-storage">
<span id="using-simple-nv"></span><h4>Using Simple NV for Flash Storage<a class="headerlink" href="#using-simple-nv-for-flash-storage" title="Permalink to this headline">¶</a></h4>
<p>The Simple NV (SNV) area of flash is used for storing persistent data, such as
encryption keys from bonding or to store custom defined parameters. The protocol
stack can be configured to reserve up to two 4kB flash pages for SNV, although
valid data is only stored in one active flash page. To minimize the number of
erase cycles on the flash, the SNV manager performs compaction on the flash
sector (or sectors) when the sector has 80% invalidated data. A compaction is
the copying of valid data to a temporary area followed by an erase of the sector
where the data was previously stored. Depending on the OSAL_SNV value as
described in <a class="reference internal" href="#osal-snv-values"><span class="std std-ref">OSAL_SNV Values</span></a>, this valid data is then either placed back
in the newly erased sector or remains in a new sector. The number of flash
sectors allocated to SNV can be configured by setting the OSAL_SNV preprocessor
symbol in the stack project. <a class="reference internal" href="#osal-snv-values"><span class="std std-numref">Table 9.</span></a> lists the valid values
that can be configured as well as the corresponding trade-offs.</p>
<table border="1" class="docutils" id="id47">
<span id="osal-snv-values"></span><caption><span class="caption-number">Table 9. </span><span class="caption-text">OSAL_SNV Values</span><a class="headerlink" href="#id47" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="18%" />
<col width="82%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>OSAL_SNV Value</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr class="row-even"><td>0</td>
<td>SNV is disabled. Storing of bonding keys in NV is not possible. Maximizes code space for the
application and/or stack project. GAP Bond Manager must be disabled. In the Stack project, set pre-
processor symbol NO_OSAL_SNV and disable GAP Bond Manager. See <a class="reference internal" href="../ble-stack/index.html#stack-features-configuration"><span class="std std-ref">Stack Configurations</span></a>
for configuring Bluetooth low energy protocol stack features.</td>
</tr>
<tr class="row-odd"><td>1 (default)</td>
<td>One flash sector is allocated to SNV. Bonding info is stored in NV. Flash compaction uses flash cache
RAM for intermediate storage, thus a power-loss during compaction results in SNV data loss. Also,
due to temporarily disabling the cache, a system performance degradation may occur during the
compaction. Set preprocessor symbol OSAL_SNV=1 in the Stack project.</td>
</tr>
<tr class="row-even"><td>2</td>
<td>Two flash sectors are allocated to SNV. Bonding information is stored in NV. SNV data is protected
against power-loss during compaction.</td>
</tr>
</tbody>
</table>
<p>Other values for OSAL_SNV are invalid. Using less than the maximum value has
the net effect of allocating more code space to the application or stack
project. SNV can be read from or written to using the following APIs.</p>
<p><strong>uint8 osal_snv_read( osalSnvId_t id, osalSnvLen_t len, void
*pBuf)</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="27%" />
<col width="73%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>&nbsp;</td>
<td><strong>Read data from NV</strong></td>
</tr>
<tr class="row-even"><td><strong>Parameters</strong></td>
<td><p class="first">id - valid NV item</p>
<p>len - length of data to read</p>
<p class="last">pBuf - pointer to buffer to store data read</p>
</td>
</tr>
<tr class="row-odd"><td><strong>Returns</strong></td>
<td><p class="first">SUCCESS: NV item read successfully</p>
<p class="last">NV_OPER_FAILED: failure reading NV item</p>
</td>
</tr>
</tbody>
</table>
<p><strong>uint8 osal_snv_write( osalSnvId_t id, osalSnvLen_t len, void
*pBuf)</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="84%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>&nbsp;</td>
<td><strong>Write data to NV</strong></td>
</tr>
<tr class="row-even"><td><strong>Parameters</strong></td>
<td><p class="first">id - valid NV item</p>
<p>len - length of data to write</p>
<p class="last">pBuf - pointer to buffer containing data to be written. All contents are updated at once.</p>
</td>
</tr>
<tr class="row-odd"><td><strong>Returns</strong></td>
<td><p class="first">SUCCESS: NV item write successfully</p>
<p class="last">NV_OPER_FAILED: failure writing NV item</p>
</td>
</tr>
</tbody>
</table>
<p>Because SNV is shared with other modules in BLE-Stack 3.00.01 such as the GAP Bond
Manager, carefully manage the NV item IDs. By default, the IDs available to the
customer are defined in bcomdef.h as shown in <a class="reference internal" href="#lst-inc-flash-snv"><span class="std std-numref">Listing 26.</span></a></p>
<div class="literal-block-wrapper docutils container" id="usable-snv-ids-available-to-customers">
<span id="lst-inc-flash-snv"></span><div class="code-block-caption"><span class="caption-number">Listing 26. </span><span class="caption-text">Usable SNV IDs available to customers</span><a class="headerlink" href="#usable-snv-ids-available-to-customers" title="Permalink to this code">¶</a></div>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">// Device NV Items -    Range 0 - 0x1F</span>
<span class="cp">#define BLE_NVID_IRK                    0x02  </span><span class="c1">//!&lt; The Device&#39;s IRK</span>
<span class="cp">#define BLE_NVID_CSRK                   0x03  </span><span class="c1">//!&lt; The Device&#39;s CSRK</span>
<span class="cp">#define BLE_NVID_SIGNCOUNTER            0x04  </span><span class="c1">//!&lt; The Device&#39;s Sign Counter</span>
<span class="cp">#define BLE_LRU_BOND_LIST               0x05  </span><span class="c1">//!&lt; The Device&#39;s order of bond indexes in least recently used order</span>

<span class="c1">// Bonding NV Items -   Range  0x20 - 0x5F    - This allows for 10 bondings</span>
<span class="cp">#define BLE_NVID_GAP_BOND_START         0x20  </span><span class="c1">//!&lt; Start of the GAP Bond Manager&#39;s NV IDs</span>
<span class="cp">#define BLE_NVID_GAP_BOND_END           0x5f  </span><span class="c1">//!&lt; End of the GAP Bond Manager&#39;s NV IDs Range</span>

<span class="c1">// GATT Configuration NV Items - Range  0x70 - 0x79 - This must match the number of Bonding entries</span>
<span class="cp">#define BLE_NVID_GATT_CFG_START         0x70  </span><span class="c1">//!&lt; Start of the GATT Configuration NV IDs</span>
<span class="cp">#define BLE_NVID_GATT_CFG_END           0x79  </span><span class="c1">//!&lt; End of the GATT Configuration NV IDs</span>

<span class="hll"><span class="c1">// Customer NV Items - Range  0x80 - 0x8F - This must match the number of Bonding entries</span>
</span><span class="hll"><span class="cp">#define BLE_NVID_CUST_START             0x80  </span><span class="c1">//!&lt; Start of the Customer&#39;s NV IDs</span>
</span><span class="hll"><span class="cp">#define BLE_NVID_CUST_END               0x8F  </span><span class="c1">//!&lt; End of the Customer&#39;s NV IDs</span>
</span></pre></div>
</td></tr></table></div>
</div>
<p><a class="reference internal" href="#lst-snv-api-usage"><span class="std std-numref">Listing 27.</span></a> shows how to read and write an array of bytes from
SNV flash:</p>
<div class="literal-block-wrapper docutils container" id="using-snv-example-code">
<span id="lst-snv-api-usage"></span><div class="code-block-caption"><span class="caption-number">Listing 27. </span><span class="caption-text">Using SNV Example Code</span><a class="headerlink" href="#using-snv-example-code" title="Permalink to this code">¶</a></div>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cm">/*********************************************************************</span>
<span class="cm">* GLOBAL VARIABLES</span>
<span class="cm">*/</span>
<span class="cp">#define BUF_LEN 4</span>
<span class="cp">#define SNV_ID_APP 0x80</span>
<span class="n">uint8</span> <span class="n">buf</span><span class="p">[</span><span class="n">BUF_LEN</span><span class="p">]</span> <span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">SimpleBLEPeripheral_taskFxn</span><span class="p">(</span><span class="n">UArg</span> <span class="n">a0</span><span class="p">,</span> <span class="n">UArg</span> <span class="n">a1</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Initialize application</span>
  <span class="n">SimpleBLEPeripheral_init</span><span class="p">();</span>
  <span class="n">uint8</span> <span class="n">status</span> <span class="o">=</span> <span class="n">SUCCESS</span><span class="p">;</span>

<span class="hll">  <span class="n">status</span> <span class="o">=</span> <span class="n">osal_snv_read</span><span class="p">(</span><span class="n">SNV_ID_APP</span><span class="p">,</span> <span class="n">BUF_LEN</span><span class="p">,</span> <span class="p">(</span><span class="n">uint8</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">);</span>
</span>  <span class="k">if</span><span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">SUCCESS</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">Display_print1</span><span class="p">(</span><span class="n">dispHandle</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;SNV READ FAIL: %d&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
    <span class="c1">//Write first time to initialize SNV ID</span>
<span class="hll">    <span class="n">osal_snv_write</span><span class="p">(</span><span class="n">SNV_ID_APP</span><span class="p">,</span> <span class="n">BUF_LEN</span><span class="p">,</span> <span class="p">(</span><span class="n">uint8</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">);</span>
</span>  <span class="p">}</span>

  <span class="c1">//Increment first element of array and write to SNV flash</span>
  <span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
<span class="hll">  <span class="n">status</span> <span class="o">=</span> <span class="n">osal_snv_write</span><span class="p">(</span><span class="n">SNV_ID_APP</span><span class="p">,</span> <span class="n">BUF_LEN</span><span class="p">,</span> <span class="p">(</span><span class="n">uint8</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">);</span>
</span>  <span class="k">if</span><span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">SUCCESS</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">Display_print1</span><span class="p">(</span><span class="n">dispHandle</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;SNV WRITE FAIL: %d&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="n">Display_print1</span><span class="p">(</span><span class="n">dispHandle</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Num of Resets: %d&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
  <span class="p">}</span>

  <span class="c1">// Application main loop</span>
  <span class="k">for</span> <span class="p">(;;)</span>
  <span class="p">{</span>
  <span class="c1">//...</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>No prior initialization of a NV item ID is required; the OSAL SNV manager
initializes the NV ID when first accessed by a successful osal_snv_write()
call.</p>
<p>When reading or writing large amounts of data to SNV, TI recommends placing the
read/write data in statically (linker) allocated arrays or buffers allocated
from the heap. Placing large amounts of data in local arrays may result in a
task stack overflow.</p>
<p>By default, osalSnvId_t and osalSnvLen_t are type defined as uint8. To use
uint16-type definitions, define the preprocessor symbol OSAL_SNV_UINT16_ID
in both the application and stack projects.</p>
<p>Using osal_snv_read and osal_snv_write is only permitted from within a task
context. Calling this API is not possible from within Swis or Hwis.</p>
</div>
<div class="section" id="customer-configuration-area">
<span id="cca"></span><h4>Customer Configuration Area<a class="headerlink" href="#customer-configuration-area" title="Permalink to this headline">¶</a></h4>
<p>The Customer Configuration Area (CCA) occupies the last page of flash and lets a
customer configure various chip and system parameters in the Customer
Configuration (CCFG) table . The CCFG table is defined in ccfg_app_ble.c,
which can be found in the Startup folder of the application project. The last
88 (sizeof(ccfg_t)) bytes of the CCA sector are reserved by the system for the
CCFG table. By default, the linker allocates the unused flash of the CCA sector
to the application image for code and data use. The linker can be modified to
reserve the entire sector for customer parameter data (for example, board serial
number and other identity parameters).</p>
<p>The CCA region is defined linker file of the application by the
FLASH_LAST_PAGE symbol. Placement is based on the IDE:</p>
<p>For CCS:</p>
<blockquote>
<div><div class="highlight-text"><div class="highlight"><pre><span></span>MEMORY
{
    ...
<span class="hll">    // CCFG Page, contains .ccfg code section and some application code.
</span><span class="hll">    FLASH_LAST_PAGE (RX) :  origin = FLASH_LAST_PAGE_START, length = FLASH_PAGE_LEN
</span>    ...
}

SECTIONS
{
    ...
<span class="hll">    .ccfg           :   &gt;  FLASH_LAST_PAGE (HIGH)
</span>    ...
}
</pre></div>
</div>
</div></blockquote>
<p>For IAR:</p>
<blockquote>
<div><div class="highlight-text"><div class="highlight"><pre><span></span>////////////////////////////////////////////////////////////////////////////////
// Memory Regions
////////////////////////////////////////////////////////////////////////////////
...
<span class="hll">define region FLASH_LAST_PAGE       = mem:[from(FLASH_SIZE - PAGE_SIZE) to FLASH_SIZE-1];
</span>...
////////////////////////////////////////////////////////////////////////////////
...
// CCFG
<span class="hll">place at end of FLASH_LAST_PAGE { readonly section .ccfg };
</span>keep { section .ccfg }
</pre></div>
</div>
</div></blockquote>
<p>See the <a class="reference external" href="http://www.ti.com/lit/pdf/swcu117">CC26xx Technical Reference Manual</a> for details on CCFG fields and related configuration options,
including how to set the CCFG to disable access to internal flash memory
contents.</p>
</div>
</div>
<div class="section" id="ram">
<span id="id11"></span><h3>RAM<a class="headerlink" href="#ram" title="Permalink to this headline">¶</a></h3>
<p>Similar to flash, the RAM is shared between the application and stack projects.
The RAM sections are configured in their respective linker files.</p>
<ul class="simple">
<li>Application Image: RAM space for the application and shared heaps. This
image is configured in the linker configuration file of the application:
cc26xx_app.icf (IAR) and cc26xx_app.cmd (CCS).</li>
<li>Stack Image: RAM space for the .bss and .data sections of the stack. This
image is configured in the linker configuration file of the stack:
cc26xx_stack.icf (IAR) and cc26xx_stack.cmd (CCS).</li>
</ul>
<div class="section" id="ram-memory-map">
<h4>RAM Memory Map<a class="headerlink" href="#ram-memory-map" title="Permalink to this headline">¶</a></h4>
<p><a class="reference internal" href="#sys-mem-map"><span class="std std-ref">System Memory Map</span></a> shows the system memory map for the default
simple_peripheral project. This is a summary and the exact memory placement for
a given compilation can be found in the simple_peripheral_app.map and
simple_peripheral_stack.map files in the output folder in IAR or the FlashROM
folder in CCS. In
<a class="reference internal" href="../debugging/ble-debugging.html#development-and-debugging-check-system-flash-and-ram-usage-with-map-file"><span class="std std-ref">Check System Flash and RAM Usage With Map File</span></a>,
the application linker file contains symbols pointed with a solid arrow and the
stack linker file contains symbols pointed with a dashed arrow.</p>
<p><strong>System Memory Map</strong></p>
<div class="figure align-center" id="sys-mem-map">
<a class="reference internal image-reference" href="../_images/image184.jpeg"><img alt="../_images/image184.jpeg" src="../_images/image184.jpeg" style="width: 75%;" /></a>
<p class="caption"><span class="caption-number">Figure 28. </span><span class="caption-text">System Memory Map</span></p>
</div>
</div>
<div class="section" id="application-and-stack-ram-boundary">
<h4>Application and Stack RAM Boundary<a class="headerlink" href="#application-and-stack-ram-boundary" title="Permalink to this headline">¶</a></h4>
<p>The application and stack RAM memory maps are based on the common
ICALL_RAM0_START defined symbol. This value defines the hard-coded RAM boundary
for the end of the RAM space of the application and the start of the image of
the stack .BSS and .DATA sections. Unlike the flash boundary, elements of the
stack project (such as task stacks and heaps) are allocated in the application
project. To ensure proper linking, both the application and stack projects must
use the same ICALL_RAM0_START value. By default, ICALL_RAM0_START is
configured to allocate unused RAM to the application project through the
frontier tool. For information on using the frontier tool to configure the RAM
boundary address, see <a class="reference internal" href="#sec-fontier-tool"><span class="std std-ref">Frontier Tool Operation</span></a>.</p>
</div>
<div class="section" id="system-stack">
<span id="sec-memory-management-system-stack"></span><h4>System Stack<a class="headerlink" href="#system-stack" title="Permalink to this headline">¶</a></h4>
<p>Besides the RTOS and ICall heaps, consider other sections of memory.
As described in <a class="reference internal" href="#sec-rtos-overview-tasks"><span class="std std-ref">Tasks</span></a>, each task has its own runtime
stack for context switching. Another runtime stack is used by the RTOS for
main(), HWIs, and SWIs. This system stack is allocated in the
application linker file to be placed at the end of the RAM of the
application.</p>
<p>For IAR, this RTOS system stack is defined by the CSTACK symbol:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="c1">////////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Stack</span>
<span class="n">define</span> <span class="n">symbol</span> <span class="n">STACK_SIZE</span>            <span class="o">=</span> <span class="mh">0x400</span><span class="p">;</span>
<span class="n">define</span> <span class="n">symbol</span> <span class="n">STACK_START</span>           <span class="o">=</span> <span class="n">RAM_END</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">define</span> <span class="n">symbol</span> <span class="n">STACK_END</span>             <span class="o">=</span> <span class="n">STACK_START</span> <span class="o">-</span> <span class="n">STACK_SIZE</span><span class="p">;</span>
<span class="c1">//</span>
<span class="n">define</span> <span class="n">symbol</span> <span class="n">STACK_TOP</span>             <span class="o">=</span> <span class="n">RAM_END</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">export</span> <span class="n">symbol</span> <span class="n">STACK_TOP</span><span class="p">;</span>

<span class="c1">// Runtime Stack</span>
<span class="n">define</span> <span class="n">block</span> <span class="n">CSTACK</span> <span class="n">with</span> <span class="n">alignment</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="n">STACK_SIZE</span> <span class="p">{</span> <span class="n">section</span> <span class="p">.</span><span class="n">stack</span> <span class="p">};</span>
<span class="n">place</span> <span class="n">at</span> <span class="n">end</span> <span class="n">of</span> <span class="n">RAM</span> <span class="p">{</span> <span class="n">block</span> <span class="n">CSTACK</span> <span class="p">};</span>
</pre></div>
</div>
<p>In IAR, to change the size of the CSTACK, adjust the STACK_SIZE symbol value in the linker file of the
application.</p>
<p>For CCS, the RTOS system stack is defined by the Program.stack
parameter in the appBLE.cfg RTOS configuration file:</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="cm">/* main() and Hwi, Swi stack size */</span>
<span class="nx">Program</span><span class="p">.</span><span class="nx">stack</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
</pre></div>
</div>
<p>and placed by the linker in the RAM space of the application:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>/* Create global constant that points to top of stack */
/* CCS: Change stack size under Project Properties */
__STACK_TOP = __stack + __STACK_SIZE;
</pre></div>
</div>
</div>
<div class="section" id="dynamic-memory-allocation">
<span id="id12"></span><h4>Dynamic Memory Allocation<a class="headerlink" href="#dynamic-memory-allocation" title="Permalink to this headline">¶</a></h4>
<p>The system uses two heaps for dynamic memory allocation. The
application designer must understand the use of each heap to
maximize the use of available memory.</p>
<p>The RTOS is configured with a small heap in the app_ble.cfg RTOS
configuration file:</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">HeapMem</span> <span class="o">=</span> <span class="nx">xdc</span><span class="p">.</span><span class="nx">useModule</span><span class="p">(</span><span class="s1">&#39;xdc.runtime.HeapMem&#39;</span><span class="p">);</span>

<span class="nx">BIOS</span><span class="p">.</span><span class="nx">heapSize</span> <span class="o">=</span> <span class="mi">1668</span><span class="p">;</span>
</pre></div>
</div>
<p>This heap (HeapMem) is used to initialize RTOS objects and allocate
the task runtime stack of the Bluetooth low energy protocol stack.
TI chose this size of this heap to meet the system initialization
requirements. Due to the small size of this heap, TI does not
recommend allocating memory from the RTOS heap for general
application use. For more information on the TI-RTOS heap
configuration, see the Heap Implementations section of the TI-RTOS
SYS/BIOS Kernel User&#8217;s Guide.</p>
<p>The application must use a separate heap. The ICall module uses an
area of application RAM which can be used by the various tasks. The
size of this ICall heap is defined by the HEAPMGR_SIZE preprocessor
definition in the application project. Using a non-zero value sets
the ICall heap to the specified value, while a HEAPMGR_SIZE value
of zero (0) auto sizes the heap to a size equal to the amount of
available free RAM not allocated by the linker. By default, the
simple_peripheral project uses the auto size feature. Although the
ICall heap is defined in the application project, this heap is also
shared with the Bluetooth low energy protocol stack. APIs that
allocate memory (such as GATT_bm_alloc()) allocate memory from the
ICall heap.</p>
<p>To profile the amount of ICall heap used, define the
HEAPMGR_METRICS preprocessor symbol in the application project.
Refer to <a class="reference internal" href="../debugging/ble-debugging.html#sect-icall-profiling"><span class="std std-ref">Profiling the ICall Heap Manager (heapmgr.h)</span></a> to determine the size of the ICall heap
when the auto heap size feature is enabled.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The auto heap size feature does not determine the amount
of heap needed for the application. The system designer must ensure
that the heap has the required space to meet the application&#8217;s
runtime memory requirements.</p>
</div>
<p>The following is an example of dynamically allocating a variable
length (n) array using the ICall heap:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="c1">//define pointer</span>
<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">pArray</span><span class="p">;</span>
<span class="c1">// Create dynamic pointer to array.</span>
<span class="k">if</span> <span class="p">(</span><span class="n">pArray</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span><span class="n">ICall_malloc</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">uint8_t</span><span class="p">)))</span>
<span class="p">{</span>
<span class="c1">//fill up array</span>
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
<span class="c1">//not able to allocate</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The following is an example of freeing the previous array:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">ICall_free</span><span class="p">(</span><span class="n">pMsg</span><span class="o">-&gt;</span><span class="n">payload</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="cache-gpram">
<h3>Cache/GPRAM<a class="headerlink" href="#cache-gpram" title="Permalink to this headline">¶</a></h3>
<p>The cache is an 8 KB section of the device&#8217;s RAM reserved for the processor. The
cache module temporarily stores data that has been read from the Flash, so that
frequently used data is not fetched from Flash on each access. This reduces CPU
wait-states and saves power. When the cache is not used, it is not powered.
This is true for Standby and Idle states where the cache is not in use.</p>
<div class="section" id="using-the-cache-as-ram">
<h4>Using the Cache as RAM<a class="headerlink" href="#using-the-cache-as-ram" title="Permalink to this headline">¶</a></h4>
<p>If your application needs more memory, or if you need more space in SRAM, the
cache can be re-purposed as RAM. This will allow the linker to store parts of
the compiled application in this section of the RAM. This section will be
referred to as the general purpose RAM (GPRAM). This will cause the program to
run at a slightly reduced speed, and it will increase the device
power consumption in sleep. This is because the GPRAM, contrary to a cache,
will have to be powered even when the device is sleeping. The current consumption
in standby mode with and without cache retained is listed in the CC2640R2F
datasheet.</p>
<p>With the cache re-purposed as RAM, the program will run at a slightly decreased
speed. This will cause the device to spend more time when active,
which again will give a higher power consumption. How this will affect the
device power consumption will depend on application. For some applications the
added power consumption will be very small, but for processing intensive
application it will be slightly higher. Please verify your application current
consumption by using the method described in <a class="reference external" href="http://www.ti.com/lit/pdf/swra478">Measuring Bluetooth Low Energy
Power Consumption Application Report (SWRA478)</a>.</p>
<p>In order to enable using the cache as RAM, two things need to be done. Firstly, the
program must be told to retain the cache/GPRAM when it&#8217;s being used. Secondly,
the linker must be told to allocate the memory region used as cache to GPRAM,
and what parts of code to store in the GPRAM. This is done in the linker
command/configuration file. The syntax for the linker command/configuration
file is slightly different in CCS and IAR. To read more about the CCS linker
command file, see the wiki article <a class="reference external" href="http://processors.wiki.ti.com/index.php/Linker_Command_File_Primer">Linker Command File Primer</a>.
To read more about the IAR linker, see <a class="reference external" href="http://ftp.iar.se/WWWfiles/arm/webic/doc/EWARM_DevelopmentGuide.ENU.pdf">IAR C/C++ Development Guide</a>.</p>
<p>Some of the example projects found in the BLE-Stack 3.00.01 have a Build Configuration
that allows using the cache as RAM. This is true for e.g. the multi_role project.
In this case, cache as RAM can be enabled by choosing that build configuration.
In CCS: Project -&gt; Build Configurations -&gt; Set Active -&gt; FlashROM-CacheAsRAM.
In IAR: Project -&gt; Edit Configurations -&gt; FlashROM-CacheAsRAM.</p>
<blockquote>
<div><div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">When changing the build configuration of a project, the project properties/options
may reset. Please make sure to make changes to the project predefines etc.,
<strong>after</strong> changing the build configuration.</p>
</div>
</div></blockquote>
<p><strong>If you want to use the cache as RAM in a project which does not have the
CacheAsRAM build configuration, follow these steps:</strong></p>
<blockquote>
<div><div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The steps will be different for CCS users and IAR users. The steps will
also differ depending on what example project your project is based on. For
the example projects found in the <code class="docutils literal"><span class="pre">blestack</span></code> folder, only step 1-5 will be required.</p>
</div>
<p>1. In the ccfg file, (called <code class="docutils literal"><span class="pre">app_ble_ccfg.c</span></code> or <code class="docutils literal"><span class="pre">ccfg.c</span></code>), include the
following <strong>before</strong>  <code class="docutils literal"><span class="pre">#include</span> <span class="pre">&lt;startup_files/ccfg.c&gt;</span></code>:</p>
<blockquote>
<div><div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#ifdef CACHE_AS_RAM</span>
  <span class="cp">#define SET_CCFG_SIZE_AND_DIS_FLAGS_DIS_GPRAM  0x0 </span><span class="cm">/* Enable GPRAM */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="c1">//CACHE_AS_RAM</span>

<span class="cp">#include</span> <span class="cpf">&lt;startup_files/ccfg.c&gt;</span><span class="cp"></span>
</pre></div>
</div>
</div></blockquote>
<ol class="arabic simple" start="2">
<li>In <code class="docutils literal"><span class="pre">main()</span></code>, add the following code:</li>
</ol>
<blockquote>
<div><div class="literal-block-wrapper docutils container" id="retain-cache-in-sleep">
<div class="code-block-caption"><span class="caption-number">Listing 28. </span><span class="caption-text">Retain cache in sleep.</span><a class="headerlink" href="#retain-cache-in-sleep" title="Permalink to this code">¶</a></div>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#ifdef CACHE_AS_RAM</span>
<span class="c1">// retain cache during standby</span>
<span class="n">Power_setConstraint</span><span class="p">(</span><span class="n">PowerCC26XX_SB_VIMS_CACHE_RETAIN</span><span class="p">);</span>
<span class="n">Power_setConstraint</span><span class="p">(</span><span class="n">PowerCC26XX_NEED_FLASH_IN_IDLE</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="c1">// Enable iCache pre-fetching</span>
<span class="n">VIMSConfigure</span><span class="p">(</span><span class="n">VIMS_BASE</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">);</span>
<span class="c1">// Enable cache</span>
<span class="n">VIMSModeSet</span><span class="p">(</span><span class="n">VIMS_BASE</span><span class="p">,</span> <span class="n">VIMS_MODE_ENABLED</span><span class="p">);</span>
<span class="cp">#endif </span><span class="c1">//CACHE_AS_RAM</span>
</pre></div>
</div>
</div>
</div></blockquote>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Please make sure your program is not using VIMS while using cache as RAM.</p>
</div>
<p>In the same file, include the following files: (In <code class="docutils literal"><span class="pre">blestack</span></code> projects,
these are already included in main.c.)</p>
<blockquote>
<div><div class="highlight-c"><div class="highlight"><pre><span></span><span class="cm">/* Power Driver */</span>
<span class="cp">#include</span> <span class="cpf">&lt;ti/drivers/Power.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;ti/drivers/power/PowerCC26XX.h&gt;</span><span class="cp"></span>
<span class="cm">/* Header files required to enable instruction fetch cache */</span>
<span class="cp">#include</span> <span class="cpf">&lt;ti/devices/cc26x0r2/inc/hw_memmap.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;ti/devices/cc26x0r2/driverlib/vims.h&gt;</span><span class="cp"></span>
</pre></div>
</div>
</div></blockquote>
<p>3. Go to the <strong>compiler</strong> predefines and add <code class="docutils literal"><span class="pre">CACHE_AS_RAM</span></code>. For the
example projects from the <code class="docutils literal"><span class="pre">blestack</span></code> folder, this define will bring changes
to the executed code in the following files:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">ble_user_config.c</span></code></li>
<li><code class="docutils literal"><span class="pre">main.c</span></code></li>
</ul>
</div></blockquote>
<p>4. Go to the <strong>linker</strong> predefines and add <code class="docutils literal"><span class="pre">CACHE_AS_RAM=1</span></code>. This define will
bring changes to the executed code in <code class="docutils literal"><span class="pre">cc26xx_app.cmd</span></code>/<code class="docutils literal"><span class="pre">cc26xx_app.icf</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>For more information on how to edit compiler and linker symbol settings
please see the following sections:</p>
<dl class="last docutils">
<dt>CCS:</dt>
<dd><ul class="first last simple">
<li><a class="reference internal" href="#sec-developing-with-ccs-accessing-preprocessor-symbols"><span class="std std-ref">Accessing Preprocessor Symbols</span></a></li>
<li><a class="reference internal" href="#sec-developing-with-ccs-accessing-linker-symbols"><span class="std std-ref">Accessing Linker Symbols</span></a></li>
</ul>
</dd>
<dt>IAR:</dt>
<dd><ul class="first last simple">
<li><a class="reference internal" href="#sec-developing-with-iar-accessing-preprocessor-symbols"><span class="std std-ref">Accessing Preprocessor Symbols</span></a></li>
<li><a class="reference internal" href="#sec-developing-with-iar-accessing-linker-symbols"><span class="std std-ref">Accessing Linker Symbols</span></a></li>
</ul>
</dd>
</dl>
</div>
<p>5. If your project is based on a <code class="docutils literal"><span class="pre">blestack</span></code> project, this will move
<code class="docutils literal"><span class="pre">.bss</span></code> from SRAM to GPRAM. Other objects can also be moved. See <a class="reference internal" href="#using-the-aux-as-ram"><span class="std std-ref">Using the AUX RAM as RAM</span></a>
for an example of this. Rebuild and flash your app project. View the .map
file to see what parts of the device memory is occupied. (Alternatively, in
CCS: View -&gt; Memory Allocation.)</p>
<p>6. If your project is not based on a <code class="docutils literal"><span class="pre">blestack</span></code> project, there are still
changes that need to be made in order to use the cache as GPRAM. If your
project is using the radio, add <code class="docutils literal"><span class="pre">0x00018063</span></code> to the radio overrides.</p>
<p>7. The GPRAM memory area must be defined in the linker command file. This
syntax is different for the CCS and IAR linker. IAR specific instructions
will follow the CCS specific instructions.</p>
<blockquote>
<div><p>In CCS, the linker command file ends with <code class="docutils literal"><span class="pre">.cmd</span></code> (e.g. <code class="docutils literal"><span class="pre">CC2640R2_LAUNCHXL_TIRTOS.cmd</span></code>).</p>
<div class="literal-block-wrapper docutils container" id="under-memory-sizes-add-defines-for-gpram-start-and-length">
<div class="code-block-caption"><span class="caption-number">Listing 29. </span><span class="caption-text">Under <code class="docutils literal"><span class="pre">Memory</span> <span class="pre">Sizes</span></code>, add defines for GPRAM start and length.</span><a class="headerlink" href="#under-memory-sizes-add-defines-for-gpram-start-and-length" title="Permalink to this code">¶</a></div>
<div class="highlight-none"><div class="highlight"><pre><span></span>  /*******************************************************************************
   * Memory Sizes
   */
  #define FLASH_BASE   0x00000000
  #define GPRAM_BASE   0x11000000
  #define RAM_BASE     0x20000000
  #define ROM_BASE     0x10000000

  #ifdef CC26X0ROM
    #define FLASH_SIZE 0x00020000
    #define GPRAM_SIZE 0x00002000
    #define RAM_SIZE   0x00005000
    #define ROM_SIZE   0x0001C000
  #endif /* CC26X0ROM */
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="add-gpram-under-memory-definitions">
<div class="code-block-caption"><span class="caption-number">Listing 30. </span><span class="caption-text">Add GPRAM under <code class="docutils literal"><span class="pre">Memory</span> <span class="pre">Definitions</span></code>.</span><a class="headerlink" href="#add-gpram-under-memory-definitions" title="Permalink to this code">¶</a></div>
<div class="highlight-c"><div class="highlight"><pre><span></span>  <span class="cm">/*******************************************************************************</span>
<span class="cm">   * GPRAM</span>
<span class="cm">   */</span>

  <span class="cp">#ifdef CACHE_AS_RAM</span>
    <span class="cp">#define GPRAM_START GPRAM_BASE</span>
    <span class="cp">#define GPRAM_END   (GPRAM_START + GPRAM_SIZE - 1)</span>
  <span class="cp">#endif </span><span class="cm">/* CACHE_AS_RAM */</span><span class="cp"></span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="in-memory-allocate-room-for-gpram">
<div class="code-block-caption"><span class="caption-number">Listing 31. </span><span class="caption-text">In <code class="docutils literal"><span class="pre">MEMORY{}</span></code>, allocate room for GPRAM.</span><a class="headerlink" href="#in-memory-allocate-room-for-gpram" title="Permalink to this code">¶</a></div>
<div class="highlight-none"><div class="highlight"><pre><span></span>  #ifdef CACHE_AS_RAM
      GPRAM(RWX) : origin = GPRAM_APP_BASE, length = GPRAM_SIZE
  #endif /* CACHE_AS_RAM */
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="in-sections-move-bss-from-sram-to-gpram">
<div class="code-block-caption"><span class="caption-number">Listing 32. </span><span class="caption-text">In <code class="docutils literal"><span class="pre">SECTIONS{}</span></code>, move .bss from SRAM to GPRAM.</span><a class="headerlink" href="#in-sections-move-bss-from-sram-to-gpram" title="Permalink to this code">¶</a></div>
<div class="highlight-none"><div class="highlight"><pre><span></span>  #ifdef CACHE_AS_RAM
  .bss            :   &gt;  GPRAM
  #endif /* CACHE_AS_RAM */

  #ifndef CACHE_AS_RAM
    .bss            :   &gt; SRAM
  #endif /* CACHE_AS_RAM */
</pre></div>
</div>
</div>
<p>Rebuild your application. This will move <code class="docutils literal"><span class="pre">.bss</span></code> from SRAM to GPRAM. Other
objects can also be moved. See <a class="reference internal" href="#using-the-aux-as-ram"><span class="std std-ref">Using the AUX RAM as RAM</span></a> for an example
of this.</p>
</div></blockquote>
<ol class="arabic simple" start="8">
<li>In IAR, the linker configuration file ends witth <code class="docutils literal"><span class="pre">.icf</span></code> (e.g. <code class="docutils literal"><span class="pre">CC2640R2_LAUNCHXL_TIRTOS.icf</span></code>).</li>
</ol>
<blockquote>
<div><div class="literal-block-wrapper docutils container" id="add-defines-for-gpram-start-and-length-under-memory-definitions">
<div class="code-block-caption"><span class="caption-number">Listing 33. </span><span class="caption-text">Add defines for GPRAM start and length under <code class="docutils literal"><span class="pre">Memory</span> <span class="pre">Definitions</span></code>.</span><a class="headerlink" href="#add-defines-for-gpram-start-and-length-under-memory-definitions" title="Permalink to this code">¶</a></div>
<div class="highlight-none"><div class="highlight"><pre><span></span>  //////////////////////////////////////////////////////////////////////////////
  // GPRAM
  //
  if ( isdefinedsymbol(CACHE_AS_RAM) )
  {
    define symbol GPRAM_START           = 0x11000000;
    define symbol GPRAM_SIZE            = 8096;
    define symbol GPRAM_END             = GPRAM_START + GPRAM_SIZE;
  }
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="under-memory-regions-allocate-room-for-gpram">
<div class="code-block-caption"><span class="caption-number">Listing 34. </span><span class="caption-text">Under <code class="docutils literal"><span class="pre">Memory</span> <span class="pre">Regions</span></code>, allocate room for GPRAM.</span><a class="headerlink" href="#under-memory-regions-allocate-room-for-gpram" title="Permalink to this code">¶</a></div>
<div class="highlight-none"><div class="highlight"><pre><span></span>  if ( isdefinedsymbol(CACHE_AS_RAM) )
  {
    define region GPRAM               = mem:[from GPRAM_START to GPRAM_END];
  }
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="under-memory-placement-move-bss-from-sram-to-gpram">
<div class="code-block-caption"><span class="caption-number">Listing 35. </span><span class="caption-text">Under <code class="docutils literal"><span class="pre">Memory</span> <span class="pre">Placement</span></code>, move .bss from SRAM to GPRAM.</span><a class="headerlink" href="#under-memory-placement-move-bss-from-sram-to-gpram" title="Permalink to this code">¶</a></div>
<div class="highlight-none"><div class="highlight"><pre><span></span>  if ( isdefinedsymbol(CACHE_AS_RAM) )
  {
    // GPRAM
    define block GPDATA { section .bss };
    place in GPRAM { block GPDATA };
  }
</pre></div>
</div>
</div>
<p>Rebuild your application. This will move <code class="docutils literal"><span class="pre">.bss</span></code> from SRAM to GPRAM. Other
objects can also be moved. See <a class="reference internal" href="#using-the-aux-as-ram"><span class="std std-ref">Using the AUX RAM as RAM</span></a> for an example
of this.</p>
</div></blockquote>
</div></blockquote>
</div>
</div>
<div class="section" id="aux-ram">
<h3>AUX RAM<a class="headerlink" href="#aux-ram" title="Permalink to this headline">¶</a></h3>
<p>The AUX RAM is a 2 KB memory area belonging to the <a class="reference internal" href="../sensor-controller/sensor-controller.html#sensor-controller"><span class="std std-ref">Sensor Controller</span></a>. If
you application does not use the Sensor Controller, you can use this memory as
RAM for your application. However, access to this memory is significantly slower
than access to the SRAM. This may lead to increased power consumption and
slower program execution.</p>
<div class="section" id="using-the-aux-ram-as-ram">
<span id="using-the-aux-as-ram"></span><h4>Using the AUX RAM as RAM<a class="headerlink" href="#using-the-aux-ram-as-ram" title="Permalink to this headline">¶</a></h4>
<p><strong>In order to use the AUX RAM with you application, follow these
steps (CCS is first described, then IAR).</strong></p>
<p>1. Make a new define in the linker command file predefines: In CCS;
Project -&gt; Properties -&gt; ARM Linker -&gt; Advanced Options -&gt; Command
File Preprocessing. In IAR; Options -&gt; Linker -&gt; Config. Add
<code class="docutils literal"><span class="pre">AUX_AS_RAM=1</span></code>.</p>
<p>2. The linker command/configuration files are somewhat different
from CCS to IAR. <strong>The instructions for altering the linker
configuration file in IAR follows the CCS specific explanations</strong>.</p>
<ul>
<li><p class="first">In the linker command file <code class="docutils literal"><span class="pre">cc26xx_app.cmd</span></code>, define the AUX_RAM
memory area:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>#ifdef AUX_AS_RAM
#define AUX_RAM_BASE            0x400E0000
#define AUX_RAM_SIZE            0x800
#endif /* AUX_AS_RAM */
</pre></div>
</div>
</li>
<li><p class="first">Create a AUX_RAM memory section in <code class="docutils literal"><span class="pre">MEMORY{}</span></code></p>
</li>
</ul>
<blockquote>
<div><div class="highlight-none"><div class="highlight"><pre><span></span>#ifdef AUX_AS_RAM
AUX_RAM (RWX) : origin = AUX_RAM_BASE, length = AUX_RAM_SIZE
#endif /* AUX_AS_RAM */
</pre></div>
</div>
</div></blockquote>
<ul>
<li><p class="first">Add sections of memory or code to AUX_RAM in <code class="docutils literal"><span class="pre">SECTIONS{}</span></code></p>
<div class="literal-block-wrapper docutils container" id="move-object-files-into-aux-ram-example-from-simple-peripheral-cc26xx-app-cmd">
<div class="code-block-caption"><span class="caption-number">Listing 36. </span><span class="caption-text">Move object files into AUX_RAM. Example from simple_peripheral (<code class="docutils literal"><span class="pre">cc26xx_app.cmd</span></code>).</span><a class="headerlink" href="#move-object-files-into-aux-ram-example-from-simple-peripheral-cc26xx-app-cmd" title="Permalink to this code">¶</a></div>
<div class="highlight-none"><div class="highlight"><pre><span></span>#ifdef AUX_AS_RAM
  reorganized_into_auxram
  {
    simple_peripheral.obj(.data)
    devinfoservice.obj(.data)
    simple_gatt_profile.obj(.data)
    icall.obj(.data)
    board.obj(.bss)
    } &gt; AUX_RAM
#endif/* AUX_AS_RAM */
</pre></div>
</div>
</div>
</li>
</ul>
<p>The .obj files are listed in the FlashROM folder of the app project.
They are also listed with size in the .map file. A detailed
description of the linker command file and memory sections is given
in the wiki article <a class="reference external" href="http://processors.wiki.ti.com/index.php/Linker_Command_File_Primer">Linker Command File Primer</a>.</p>
<p>If you want more control over what is stored in AUX_RAM, individual
variables can be stored there with the <code class="docutils literal"><span class="pre">#pragma</span> <span class="pre">DATA_SECTION</span></code> command.
Please note that this is only possible for global variables.</p>
<blockquote>
<div><div class="literal-block-wrapper docutils container" id="move-the-global-display-handle-variable-into-a-new-aux-ram-section-called-my-section">
<div class="code-block-caption"><span class="caption-number">Listing 37. </span><span class="caption-text">Move the global <em>display handle</em> variable into a new  AUX RAM section called <code class="docutils literal"><span class="pre">my_section</span></code>.</span><a class="headerlink" href="#move-the-global-display-handle-variable-into-a-new-aux-ram-section-called-my-section" title="Permalink to this code">¶</a></div>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="c1">// Display Interface</span>
<span class="cp">#pragma DATA_SECTION(dispHandle, &quot;my_section&quot;)</span>
<span class="n">Display_Handle</span> <span class="n">dispHandle</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="in-the-linker-command-file-cc26xx-app-cmd-add-the-section-to-aux-ram">
<div class="code-block-caption"><span class="caption-number">Listing 38. </span><span class="caption-text">In the linker command file (<code class="docutils literal"><span class="pre">cc26xx_app.cmd</span></code>), add the section to AUX_RAM.</span><a class="headerlink" href="#in-the-linker-command-file-cc26xx-app-cmd-add-the-section-to-aux-ram" title="Permalink to this code">¶</a></div>
<div class="highlight-none"><div class="highlight"><pre><span></span>#ifdef AUX_AS_RAM
  reorganized_into_auxram
  {
    simple_peripheral.obj(my_section)
  } &gt; AUX_RAM
#endif /* AUX_AS_RAM */
</pre></div>
</div>
</div>
</div></blockquote>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">When making alterations only to the linker command file, please make sure to
press <em>Rebuild</em>, not just <em>Build</em>.
(CCS will not recognize that you have made changes to the project before you
press <em>Rebuild</em>.)</p>
</div>
<ol class="arabic simple" start="3">
<li><strong>For IAR</strong>, open the linker configuration file <code class="docutils literal"><span class="pre">cc26xx_app.icf</span></code>. Under <code class="docutils literal"><span class="pre">Memory</span> <span class="pre">Definitions</span></code>, add</li>
</ol>
<blockquote>
<div><div class="highlight-none"><div class="highlight"><pre><span></span>////////////////////////////////////////////////////////////////////////////////
// AUX_RAM
//
if ( isdefinedsymbol(AUX_AS_RAM) )
{
  define symbol AUX_RAM_START        = 0x400E0000;
  define symbol AUX_RAM_SIZE         = 0x800;
  define symbol AUX_RAM_END          = AUX_RAM_START + AUX_RAM_SIZE;
}
</pre></div>
</div>
</div></blockquote>
<ul>
<li><p class="first">Under <code class="docutils literal"><span class="pre">Memory</span> <span class="pre">Regions</span></code>, add</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>if ( isdefinedsymbol(AUX_AS_RAM) )
{
  define region AUX_RAM               = mem:[from AUX_RAM_START to AUX_RAM_END];
}
</pre></div>
</div>
</li>
<li><p class="first">Under <code class="docutils literal"><span class="pre">Memory</span> <span class="pre">Placement</span></code>, add</p>
<div class="literal-block-wrapper docutils container" id="move-object-files-into-aux-ram-example-from-simple-peripheral-cc26xx-app-icf">
<div class="code-block-caption"><span class="caption-number">Listing 39. </span><span class="caption-text">Move object files into AUX_RAM. Example from simple_peripheral (<code class="docutils literal"><span class="pre">cc26xx_app.icf</span></code>).</span><a class="headerlink" href="#move-object-files-into-aux-ram-example-from-simple-peripheral-cc26xx-app-icf" title="Permalink to this code">¶</a></div>
<div class="highlight-none"><div class="highlight"><pre><span></span>if ( isdefinedsymbol(AUX_AS_RAM) )
{
  // AUX_RAM
  define block AUXDATA { section .data object simple_peripheral.o,
                         section .data object devinfoservice.o,
                         section .data object simple_gatt_profile,
                         section .data object icall.o,
                         section .data object board.o};
  place in AUX_RAM { block AUXDATA };
}
</pre></div>
</div>
</div>
</li>
</ul>
<p>The .o-files are listed in the .map file. For more information on the linker
configuration file, please see <a class="reference external" href="http://ftp.iar.se/WWWfiles/arm/webic/doc/EWARM_DevelopmentGuide.ENU.pdf">IAR C/C++ Development Guide</a>.</p>
<p>If you want more control over what is stored in AUX_RAM, individual
variables can be stored there with the <code class="docutils literal"><span class="pre">#pragma</span> <span class="pre">location</span></code> command.
Please note that this is only possible for global variables.</p>
<blockquote>
<div><div class="literal-block-wrapper docutils container" id="move-the-global-display-handle-variable-into-a-new-cache-ram-section-called-my-section">
<div class="code-block-caption"><span class="caption-number">Listing 40. </span><span class="caption-text">Move the global <em>display handle</em> variable into a new Cache RAM section called <code class="docutils literal"><span class="pre">my_section</span></code>.</span><a class="headerlink" href="#move-the-global-display-handle-variable-into-a-new-cache-ram-section-called-my-section" title="Permalink to this code">¶</a></div>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="c1">// Display Interface</span>
<span class="cp">#pragma location=&quot;my_section&quot;</span>
<span class="n">Display_Handle</span> <span class="n">dispHandle</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="in-the-linker-configuration-file-cc26xx-app-cmd-add-the-section-to-aux-ram">
<div class="code-block-caption"><span class="caption-number">Listing 41. </span><span class="caption-text">In the linker configuration file (<code class="docutils literal"><span class="pre">cc26xx_app.cmd</span></code>), add the section to AUX_RAM.</span><a class="headerlink" href="#in-the-linker-configuration-file-cc26xx-app-cmd-add-the-section-to-aux-ram" title="Permalink to this code">¶</a></div>
<div class="highlight-none"><div class="highlight"><pre><span></span>if ( isdefinedsymbol(AUX_AS_RAM) )
{
  // AUX_RAM
  define block AUXDATA { section my_section object simple_peripheral.o };
  place in AUX_RAM { block AUXDATA };
}
</pre></div>
</div>
</div>
</div></blockquote>
</div>
</div>
<div class="section" id="frontier-tool">
<h3>Frontier Tool<a class="headerlink" href="#frontier-tool" title="Permalink to this headline">¶</a></h3>
<p>The frontier tool is a utility to automatically adjust the respective RAM and
flash boundary address symbols shared between the application and stack
projects built as <strong>split images</strong>. Project where the application consumes the
stack as a library do not require the use of the Frontier Tool.</p>
<p>Frontier runs as a post-build step of the stack project, and adjusts
the respective RAM and flash boundaries based on analysis of the stack linker
and map files. No project files are modified by the frontier tool. The frontier
tool does not modify any source code or perform any compiler or linker
optimization; the tool adjusts and updates the respective flash and RAM boundary
addresses, located in the compiler and linker configuration files used by the
application and stack projects.</p>
<p>The frontier tool is installed to the following path within the SDK:
<em>&lt;SDK_INSTALL_DIR&gt;\examples\rtos\CC2640R2_LAUNCHXL\blestack\tools\frontier\frontier.exe</em></p>
<p>The python source for this tool is also included.</p>
<p><a class="reference internal" href="#boundary-address-symbols-table"><span class="std std-numref">Table 10.</span></a> shows the boundary address symbols
updated by the frontier tool.</p>
<table border="1" class="docutils" id="id48">
<span id="boundary-address-symbols-table"></span><caption><span class="caption-number">Table 10. </span><span class="caption-text">Boundary Address Symbols</span><a class="headerlink" href="#id48" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="36%" />
<col width="64%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Boundary Address Symbol</th>
<th class="head">Definition</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>ICALL_STACK0_START</td>
<td>Boundary flash address between application and stack
images. Represents the end of the application image and
the beginning of the stack image.</td>
</tr>
<tr class="row-odd"><td>ICALL_STACK0_ADDR</td>
<td>Stack entry address (flash)</td>
</tr>
<tr class="row-even"><td>ICALL_RAM0_START</td>
<td>Boundary RAM address between application and stack
images. Represents the end of the application RAM and
the beginning of the stack RAM.</td>
</tr>
</tbody>
</table>
<p>All sample application projects are, by default, configured to use
the frontier tool; thus, no user configuration of the frontier tool
is required. The boundary files may be updated when the stack
configuration is changed, or when any files are updated in the stack
project that result in a change in the size of the stack image. It
is therefore required to rebuild the application project anytime the
stack project is built.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The frontier tool replaces the boundary tool used in earlier SDKs.</p>
</div>
<div class="section" id="frontier-tool-operation">
<span id="sec-fontier-tool"></span><h4>Frontier Tool Operation<a class="headerlink" href="#frontier-tool-operation" title="Permalink to this headline">¶</a></h4>
<p>The frontier tool (frontier.exe) is invoked as a CCS or IAR IDE
post-build operation of the stack project. If an adjustment to the
RAM or flash boundary is required, the frontier tool updates the
boundary linker configuration and C definition files listed below.
To incorporate the updated configuration values, perform a
Project -&gt;  Rebuild All on the application project. The stack
project must build and link correctly before the application can be
rebuilt.</p>
<p>Each project in the SDK has a set of configuration files that the
linker and compiler of the IDE use to set or adjust the respective
flash and RAM values. These configuration files are shared between
the application and stack workspaces, and are stored at the
following location:</p>
<p><em>&lt;SDK_INSTALL_DIR&gt;\examples\rtos\&lt;EVAL_BOARD&gt;\blestack\&lt;PROJECT&gt;\tirtos\&lt;IDE&gt;\config</em></p>
<p>Where &lt;EVAL_BOARD&gt; is the evaluation platform, &lt;PROJECT&gt; is the
sample application (for example, simple_peripheral), and &lt;IDE&gt; is
either IAR or CCS.</p>
<p>For example, the simple_peripheral sample application running on the CC2640R2F
LaunchPad, the boundary config files are located at the following
paths:</p>
<p>CCS:
<em>&lt;SDK_INSTALL_DIR&gt;\examples\rtos\CC2640R2_LAUNCHXL\blestack\simple_peripheral\tirtos\ccs\config</em></p>
<p>IAR:
<em>&lt;SDK_INSTALL_DIR&gt;\examples\rtos\CC2640R2_LAUNCHXL\blestack\simple_peripheral\tirtos\iar\config</em></p>
<p>The following are the boundary config files:</p>
<ul class="simple">
<li>Boundary linker configuration file: iar_boundary.xcl [IAR] or
ccs_linker_defines.cmd [CCS]. Defines the boundary addresses
for the linker. This file is in the TOOLS IDE folder and is
updated by the frontier tool when an adjustment is required.</li>
<li>Boundary C definition file: iar_boundary.bdef [IAR] or
ccs_compiler_defines.bcfg [CCS]. Defines the boundary addresses
for the compiler. This file is in the TOOLS IDE folder and is
updated by the frontier tool when an adjustment is required.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The values in the boundary linker configuration file and the boundary
C definition file must match.</p>
</div>
</div>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../ble-stack/index.html" class="btn btn-neutral float-right" title="Developing a Bluetooth Low Energy Application" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="get-started/get-started.html" class="btn btn-neutral" title="Getting Started" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, Texas Instruments.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'3.00.01',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: ''
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>